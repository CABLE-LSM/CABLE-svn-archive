!jhan:include knode capability - and how much can i keep? test this on vayu with UM aswell
MODULE air_module
   use define_dimensions, only : mp, r_1
   IMPLICIT NONE
   PUBLIC define_air
   PRIVATE

   character(len=10) :: filenamein = "air_in"
   character(len=10) :: filenameout = "air_out"
   
   interface define_air
      module procedure  define_air_cable, define_air_comp
   end interface define_air
   
CONTAINS

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   SUBROUTINE define_air_cable(met,air)
      use define_types, only : air_type, met_type    
      use cable_data_module, only : const, air_in, air_out
      implicit none
      TYPE (air_type), INTENT(INOUT) :: air ! air_type variables
      TYPE (met_type), INTENT(IN)  :: met ! meteorological variables
      type (air_in),dimension(2) :: i
      type (air_out) :: o

      i(1)%met_tvair    => met%tvair 
      i(1)%met_pmb      => met%pmb 
      
      o%air_cmolar   => air%cmolar
      o%air_rho      => air%rho          
      o%air_rlam     => air%rlam          
      o%air_epsi     => air%epsi          
      o%air_visc     => air%visc         
      o%air_psyc     => air%psyc         
      o%air_dsatdk   => air%dsatdk       
      
      !jhan:atleast interface this to include o 
      call dump_air_in(i(1))
      !call read_air_in(i)

      call new_define_air(i(1),o)

      call dump_air_out(o)

      return
   END SUBROUTINE define_air_cable
      



   SUBROUTINE define_air_comp()
      use cable_data_module, only : const, air_in, air_out
      implicit none
      type (air_in),dimension(2) :: i
      type (air_out) :: o

      !jhan:atleast interface this to include o 
      call read_air_in(i(1))

      call new_define_air(i(1),o)

      return
   END SUBROUTINE define_air_comp
      

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   subroutine new_define_air(i,o)
      use cable_common_module, only : cable_user
      use cable_diag_module, only : cable_stat
      use cable_data_module, only : const, air_in, air_out
      use define_dimensions, only : mp, r_1
      implicit none
      !type (air_in), intent(in), dimension(2) :: i
      type (air_in), intent(in) :: i
      type (air_out), intent(out) :: o
      integer :: j 
      real, dimension(mp)     :: &
         es,   &    !sat vapour pressure (mb)   
         !used in Mk3L driver. make local  
         volm, &   
         qsat

      real, pointer     :: &
         CAPP, &     ! sdsgdsgdhdhdfhfdbdbdds 
         HL, &       ! sdsgdsgdhdhdfhfdbdbdds   
         RGAS, &     ! sdsgdsgdhdhdfhfdbdbdds 
         RMAIR, &    ! sdsgdsgdhdhdfhfdbdbdds 
         RMH2O, &    ! sdsgdsgdhdhdfhfdbdbdds 
         TFRZ, &     ! sdsgdsgdhdhdfhfdbdbdds 
         TETENA, &   ! sdsgdsgdhdhdfhfdbdbdds 
         TETENB, &   ! sdsgdsgdhdhdfhfdbdbdds 
         TETENC      ! sdsgdsgdhdhdfhfdbdbdds 

         CAPP    => const%phys%capp  
         HL      => const%phys%hl       
         RGAS    => const%phys%rgas  
         RMAIR   => const%phys%rmair 
         RMH2O   => const%phys%rmh2o 
         TFRZ    => const%phys%tfrz  
         TETENA  => const%phys%tetena  
         TETENB  => const%phys%tetenb  
         TETENC  => const%phys%tetenc  

         if( cable_user%RUN_DIAG_LEVEL == 'BASIC' ) &    
           call cable_stat('define_air')
    
         ! Calculate saturation vapour pressure
         es = TETENA * EXP(TETENB * (i%met_tvair-TFRZ)/(TETENC + (i%met_tvair-TFRZ)))
     
         ! Calculate conversion factor from from m/s to mol/m2/s
         o%air_cmolar = i%met_pmb * 100.0 / (RGAS * (i%met_tvair))
         
         ! Calculate dry air density:
         o%air_rho = MIN(1.3,RMAIR * o%air_cmolar)
         
         ! molar volume (m^3/mol)
         volm = RGAS * (i%met_tvair) / (100.0 * i%met_pmb)
   
         ! latent heat for water (j/kg)
         !o%air%rlam = (2501.0 - 2.38 * (met%tvair- tfrz)) * 1000.0
         o%air_rlam= HL
         ! saturation specific humidity
         qsat = (RMH2O / RMAIR) * es / i%met_pmb
   
         ! d(qsat)/dT ((kg/kg)/K)
         o%air_epsi = (o%air_rlam / CAPP) * (RMH2O / RMAIR) * es * TETENB * TETENC / &
              &  (TETENC + (i%met_tvair - TFRZ)) ** 2 / i%met_pmb
         
         ! air kinematic viscosity (m^2/s)
         o%air_visc = 1e-5 * MAX(1.0, 1.35 + 0.0092 * (i%met_tvair - TFRZ))
         
         ! psychrometric constant
         o%air_psyc = i%met_pmb * 100.0 * CAPP * RMAIR / o%air_rlam / RMH2O
         
         ! d(es)/dT (mb/K)
         o%air_dsatdk = 100.0*(TETENA*TETENB*TETENC)/((i%met_tvair-TFRZ)+TETENC)**2 &
              * EXP(TETENB*(i%met_tvair-TFRZ)/((i%met_tvair-TFRZ) + TETENC))
      return
   end subroutine new_define_air

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   subroutine dump_air_in(i)
      use cable_data_module, only : air_in
      implicit none
      type (air_in), intent(in) :: i
      integer :: gopenstatus
      
      open(unit=713940,file=trim(filenamein)//'.bin',status="unknown",action="write", &
         iostat=gopenstatus, form="unformatted", position='append' )
      if(gopenstatus==0) then
         write (713940) i%met_tvair, i%met_pmb 
      else
         write (*,*) trim(filenamein)//'.bin',' NOT open for write. Error'
      endif
      close(713940)
      
      return
   end subroutine dump_air_in



   subroutine read_air_in(i)
      use cable_data_module, only : air_in
      implicit none
      type (air_in), intent(inout) :: i
      integer,save :: gopenstatus
      logical :: lopen
       
      inquire(unit=813940,opened=lopen)
      if (.NOT. lopen) &
         open(unit=813940,file=trim(filenamein)//'.bin',status="unknown",action="read", &
            iostat=gopenstatus, form="unformatted" )
         if(gopenstatus==0) then
            read(813940) i%met_tvair, i%met_pmb 
         else
            write (*,*) trim(filenamein)//'.bin',' NOT open for READ. Error'
         endif

         !DONT close(813940) to maintain position
      
      return
   end subroutine read_air_in



   subroutine dump_air_out(o)
      use cable_data_module, only : air_out
      implicit none
      type (air_out), intent(in) :: o
      integer :: gopenstatus
      
      open(unit=713941,file=trim(filenameout)//'.bin',status="unknown",action="write", &
         iostat=gopenstatus, form="unformatted", position='append' )
      if(gopenstatus==0) then
         write(713941)  o%air_cmolar, o%air_rho, o%air_rlam, o%air_epsi,  &
               o%air_visc, o%air_psyc, o%air_dsatdk 
      else
         write (*,*) trim(filenameout)//'.bin',' NOT open for write. Error'
      endif
      close(713941)
      
      return
   end subroutine dump_air_out





END MODULE air_module


