
MODULE air_module
   use define_dimensions, only : mp, r_1
   IMPLICIT NONE
   PUBLIC define_air
   PRIVATE

   character(len=10) :: filename = "air"

   type air_in
      real,dimension(:), pointer     :: &
         met_tvair, &
         met_pmb
   end type air_in

   type air_out
      real, dimension(:), pointer     :: &
         air_cmolar, &
         air_rho, &
         air_rlam, &
         air_dsatdk, &
         air_epsi, & 
         air_visc, & 
         air_psyc 
   end type air_out


CONTAINS


   SUBROUTINE define_air(met,air)
      use define_types, only : air_type, met_type    
      use define_dimensions, only : mp, r_1
      use cable_common_module, only : cable_user
      use cable_diag_module, only : cable_stat
      use cable_data_module, only : const
      implicit none
      TYPE (air_type), INTENT(INOUT) :: air ! air_type variables
      TYPE (met_type), INTENT(IN)  :: met ! meteorological variables
      type (air_in) :: i
      type (air_out) :: o

      i%met_tvair    => met%tvair 
      i%met_pmb      => met%pmb 
      
      o%air_cmolar   => air%cmolar
      o%air_rho      => air%rho          
      o%air_rlam     => air%rlam          
      o%air_epsi     => air%epsi          
      o%air_visc     => air%visc         
      o%air_psyc     => air%psyc         
      o%air_dsatdk   => air%dsatdk       
      
      !jhan:atleast interface this to include o 
      !call dump_air(i)
      call read_air(i, mp)

      call new_define_air(i,o)

      return
   END SUBROUTINE define_air
      



   subroutine new_define_air(i,o)
      use cable_common_module, only : cable_user
      use cable_diag_module, only : cable_stat
      use cable_data_module, only : const
      use define_dimensions, only : mp, r_1
      implicit none
      type (air_in), intent(in) :: i
      type (air_out), intent(out) :: o
      integer :: j 
      real, dimension(mp)     :: &
         es,   &    !sat vapour pressure (mb)   
         !used in Mk3L driver. make local  
         volm, &   
         qsat

      real, pointer     :: &
         CAPP, &  
         HL, &      
         RGAS, &  
         RMAIR, & 
         RMH2O, & 
         TFRZ, &  
         TETENA, & 
         TETENB, & 
         TETENC 

         CAPP    => const%phys%capp  
         HL      => const%phys%hl       
         RGAS    => const%phys%rgas  
         RMAIR   => const%phys%rmair 
         RMH2O   => const%phys%rmh2o 
         TFRZ    => const%phys%tfrz  
         TETENA  => const%phys%tetena  
         TETENB  => const%phys%tetenb  
         TETENC  => const%phys%tetenc  

         if( cable_user%RUN_DIAG_LEVEL == 'BASIC' ) &    
           call cable_stat('define_air')
    
         ! Calculate saturation vapour pressure
         es = TETENA * EXP(TETENB * (i%met_tvair-TFRZ)/(TETENC + (i%met_tvair-TFRZ)))
     
         ! Calculate conversion factor from from m/s to mol/m2/s
         o%air_cmolar = i%met_pmb * 100.0 / (RGAS * (i%met_tvair))
         
         ! Calculate dry air density:
         o%air_rho = MIN(1.3,RMAIR * o%air_cmolar)
         
         ! molar volume (m^3/mol)
         volm = RGAS * (i%met_tvair) / (100.0 * i%met_pmb)
   
         ! latent heat for water (j/kg)
         !o%air%rlam = (2501.0 - 2.38 * (met%tvair- tfrz)) * 1000.0
         o%air_rlam= HL
         ! saturation specific humidity
         qsat = (RMH2O / RMAIR) * es / i%met_pmb
   
         ! d(qsat)/dT ((kg/kg)/K)
         o%air_epsi = (o%air_rlam / CAPP) * (RMH2O / RMAIR) * es * TETENB * TETENC / &
              &  (TETENC + (i%met_tvair - TFRZ)) ** 2 / i%met_pmb
         
         ! air kinematic viscosity (m^2/s)
         o%air_visc = 1e-5 * MAX(1.0, 1.35 + 0.0092 * (i%met_tvair - TFRZ))
         
         ! psychrometric constant
         o%air_psyc = i%met_pmb * 100.0 * CAPP * RMAIR / o%air_rlam / RMH2O
         
         ! d(es)/dT (mb/K)
         o%air_dsatdk = 100.0*(TETENA*TETENB*TETENC)/((i%met_tvair-TFRZ)+TETENC)**2 &
              * EXP(TETENB*(i%met_tvair-TFRZ)/((i%met_tvair-TFRZ) + TETENC))
      return
   end subroutine new_define_air



   subroutine dump_air(i)
      implicit none
      type (air_in), intent(in) :: i
      integer :: gopenstatus
      
      open(unit=713940,file=trim(filename)//'.bin',status="unknown",action="write", &
         iostat=gopenstatus, form="unformatted", position='append' )
      if(gopenstatus==0) then
            write (713940) i%met_tvair*.9, i%met_pmb*.9 
      else
         write (*,*) filename//'.bin',' NOT open for write. Error'
      endif
      close(713940)
      
      return
   end subroutine dump_air



   subroutine read_air(i, mp)
      implicit none
      type (air_in), intent(inout) :: i
      integer, intent(in) :: mp
      integer,save :: gopenstatus
      logical :: lopen
      real, dimension(mp) :: tvair, pmb
       
      inquire(unit=813940,opened=lopen)
      if (.NOT. lopen) &
         open(unit=813940,file=trim(filename)//'.bin',status="unknown",action="read", &
            iostat=gopenstatus, form="unformatted" )
         if(gopenstatus==0) then
            read(813940) tvair, pmb 
         else
            write (*,*) filename//'.bin',' NOT open for READ. Error'
         endif
         i%met_tvair    = tvair 
         i%met_pmb      = pmb 

         !close(813940)
      
      return
   end subroutine read_air




END MODULE air_module


