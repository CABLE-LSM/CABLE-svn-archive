!==============================================================================
! This source code is part of the 
! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model.
! This work is licensed under the CABLE Academic User Licence Agreement 
! (the "Licence").
! You may not use this file except in compliance with the Licence.
! A copy of the Licence and registration form can be obtained from 
! http://www.accessimulator.org.au/cable
! You need to register and read the Licence agreement before use.
! Please contact cable_help@nf.nci.org.au for any questions on 
! registration and the Licence.
!
! Unless required by applicable law or agreed to in writing, 
! software distributed under the Licence is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the Licence for the specific language governing permissions and 
! limitations under the Licence.
! ==============================================================================
!
! Purpose: All routines for calculating soil temperature and moisture
!          and snow calculations
!
! Contact: Eva.Kowalczyk@csiro.au
!
! History: v2.0 Tighter water budget
!          v2.0 Hydraulic redistribution subroutine (with namelist switch). 
!               NB Currently hard-wired to veg types 2 and 7 
!                  (usually evergreen broadleaf and c4 grass)
!          v2.0 ssoil variable renamed ssnow
!          Mark Decker - used ssnow as base for ssgw.  Could be part of same module
!
! ==============================================================================

MODULE cable_gw_hydro_module
   
   USE cable_def_types_mod, ONLY : soil_snow_type, soil_parameter_type,        &
                             veg_parameter_type, canopy_type, met_type,        &
                             balances_type, r_2, ms, mp,mland

   USE cable_data_module, ONLY : issnow_type, point2constants

   USE cable_common_module, ONLY : gw_params,cable_user

   USE cable_soil_snow_module, ONLY : snowdensity, snow_melting, snowcheck, &
                                       snowl_adjust,snow_accum, stempv,trimb,&
                                       cgsnow,csice,cswat,snmin,max_ssdn,&
                                       max_glacier_snowd,max_sconds


   IMPLICIT NONE

   PRIVATE
   
  TYPE ( issnow_type ), SAVE :: C
  

   !mrd561 GW params
   !Should read some in from namelist
   REAL(r_2), PARAMETER :: sucmin  = -1.0e8, &! minimum soil pressure head [mm]
                      volwatmin    = 1e-4,        &!min soil water [mm]      
                      wtd_uncert   = 0.1,         &! uncertaintiy in wtd calcultations [mm]
                      wtd_max      = 150000.0,    &! maximum wtd [mm]
                      wtd_min      = 0.0,       &! minimum wtd [mm]
                      dri          = 1.0           !ratio of density of ice to density of liquid [unitless]

   INTEGER, PARAMETER :: wtd_iter_max = 20 ! maximum number of iterations to find the water table depth                    
   
  ! ! This module contains the following subroutines:
   PUBLIC soil_snow_gw,calc_srf_wet_fraction,sli_hydrology ! must be available outside this module
   PUBLIC saturated_fraction,pore_space_relative_humidity,set_unsed_gw_vars
   PUBLIC sucmin,volwatmin,wtd_uncert,wtd_max,wtd_min,dri,wtd_iter_max

   PRIVATE subsurface_drainage,iterative_wtd,ovrlndflx,aquifer_recharge, calc_soil_hydraulic_props
   PRIVATE calc_equilibrium_water_content
   PRIVATE GWsoilfreeze, remove_transGW,explicit_wtd, GWstempv
   PRIVATE smoistgw,my_erf

CONTAINS


! -----------------------------------------------------------------------------
!
! -----------------------------------------------------------------------------

SUBROUTINE GWsoilfreeze(dels, soil, ssnow)
   USE cable_common_module
   REAL, INTENT(IN)                    :: dels ! integration time step (s)
   TYPE(soil_snow_type), INTENT(INOUT)      :: ssnow
   TYPE(soil_parameter_type), INTENT(INOUT)    :: soil
   REAL(r_2), DIMENSION(mp)           :: sicefreeze
   REAL(r_2), DIMENSION(mp)           :: sicemelt
   REAL, DIMENSION(mp)                :: xx, ice_mass,liq_mass,tot_mass
   INTEGER :: i,j,k
   REAL(r_2),DIMENSION(mp,ms+1) :: max_ice_frac,iceF  !Decker and Zeng 2009

   CALL point2constants( C ) 

   do k=1,ms
   do i=1,mp
      if  (ssnow%tgg(i,k) .lt. C%TFRZ) then
         max_ice_frac(i,k) = (1.0 - exp(-2.*(ssnow%wb(i,k)/soil%ssat_vec(i,k))**4.0 *&
                          (ssnow%tgg(i,k)-C%TFRZ)))/exp(1. - ssnow%wb(i,k)/soil%ssat_vec(i,k))
         max_ice_frac(i,k) = max(0.4,max_ice_frac(i,k))
      else
         max_ice_frac(i,k) = 0.
      endif
   end do
   end do

   max_ice_frac(:,ms+1) = 0.95

   !allow more freezing for permenant glacier ice regions
   do i=1,mp
      if (soil%isoilm(i) .eq. 9) max_ice_frac(i,:) = 0.95
   end do

   xx = 0.
   DO k = 1, ms
   DO i=1,mp

      ice_mass = ssnow%wbice(i,k)*soil%zse_vec(i,k)*real(C%density_ice,r_2)
      liq_mass = ssnow%wbliq(i,k)*soil%zse_vec(i,k)*real(C%density_liq,r_2)
      tot_mass = liq_mass + ice_mass
      
      if (ssnow%tgg(i,k) .lt. C%TFRZ .and. &
           max_ice_frac(i,k) * ssnow%wb(i,k) - ssnow%wbice(i,k) > .001) then
         
         sicefreeze(i) = MIN( MAX( 0.0_r_2, ( max_ice_frac(i,k) * ssnow%wb(i,k) -      &
                      ssnow%wbice(i,k) ) ) * soil%zse_vec(i,k) * C%density_ice,             &
                      ( C%TFRZ - ssnow%tgg(i,k) ) * ssnow%gammzz(i,k) / C%HLF )
         ssnow%wbice(i,k) = MIN( ssnow%wbice(i,k) + sicefreeze(i) / (soil%zse_vec(i,k)  &
                            * 1000.0), max_ice_frac(i,k) * ssnow%wb(i,k) )
         xx(i) = soil%css_vec(i,k) * soil%rhosoil_vec(i,k)
         ssnow%gammzz(i,k) = MAX(                                              &
             ((1._r_2 - soil%ssat_vec(i,k)) * soil%css_vec(i,k) * soil%rhosoil_vec(i,k)) &
             + (ssnow%wb(i,k) - ssnow%wbice(i,k)) * REAL(cswat * C%density_liq,r_2)   &
             + ssnow%wbice(i,k) * REAL(csice * C%density_ice,r_2),              &
             soil%css_vec(i,k) * soil%rhosoil_vec(i,k)) * soil%zse_vec(i,k)

        if (k .eq. 1 .and. ssnow%isflag(i) .eq. 0) then
           ssnow%gammzz(i,k) = ssnow%gammzz(i,k) + cgsnow * ssnow%snowd(i)
        end if

         ssnow%tgg(i,k) = ssnow%tgg(i,k) + REAL(sicefreeze(i))                    &
                             * C%HLF / REAL(ssnow%gammzz(i,k) )

     
      ELSEIF( ssnow%tgg(i,k) > C%TFRZ .AND. ssnow%wbice(i,k) > 0. ) then
         
         sicemelt(i) = MIN( ssnow%wbice(i,k) * soil%zse_vec(i,k) * C%density_ice,              &
                    ( ssnow%tgg(i,k) - C%TFRZ ) * ssnow%gammzz(i,k) / C%HLF )
         
         ssnow%wbice(i,k) = MAX( 0.0_r_2, ssnow%wbice(i,k) - sicemelt(i)          &
                            / (soil%zse_vec(i,k) * C%density_ice) )
         ssnow%gammzz(i,k) = MAX(                                              &
              ((1._r_2-soil%ssat_vec(i,k)) * soil%css_vec(i,k) * soil%rhosoil_vec(i,k)) &
              + (ssnow%wb(i,k) - ssnow%wbice(i,k)) * REAL(cswat*C%density_liq,r_2)   &
              + ssnow%wbice(i,k) * REAL(csice * C%density_ice,r_2),            &
              soil%css_vec(i,k) * soil%rhosoil_vec(i,k) ) * soil%zse_vec(i,k)
         if (k .eq. 1 .and. ssnow%isflag(i) .eq. 0) then
           ssnow%gammzz(i,k) = ssnow%gammzz(i,k) + cgsnow * ssnow%snowd(i)
         end if
         ssnow%tgg(i,k) = ssnow%tgg(i,k) - REAL(sicemelt(i))                     &
                          * C%HLF / REAL(ssnow%gammzz(i,k))
       
      END IF
      !update the liq and ice volume and mass
      ice_mass(i)   = ssnow%wbice(i,k)*soil%zse_vec(i,k)*real(C%density_ice,r_2)
      liq_mass(i)   = tot_mass(i) - ice_mass(i)
      ssnow%wbliq(i,k) = liq_mass(i) / soil%zse_vec(i,k)/real(C%density_liq,r_2)
      ssnow%wbice(i,k) = ice_mass(i) / soil%zse_vec(i,k)/real(C%density_ice,r_2)
      ssnow%wb(i,k)    = ssnow%wbliq(i,k) + ssnow%wbice(i,k)
    
   END DO
   END DO

END SUBROUTINE GWsoilfreeze
!
!!-----------------------------------------------------------------------------------------
!
!! -----------------------------------------------------------------------------
!
SUBROUTINE remove_transGW(dels, soil, ssnow, canopy, veg)
   
   USE cable_common_module, ONLY : redistrb

   ! Removes transpiration water from soil.
   REAL, INTENT(IN)                    :: dels ! integration time step (s)
   TYPE(canopy_type), INTENT(INOUT)         :: canopy
   TYPE(soil_snow_type), INTENT(INOUT)      :: ssnow
   TYPE(soil_parameter_type), INTENT(INOUT)    :: soil
   TYPE(veg_parameter_type), INTENT(INOUT)  :: veg
   REAL(r_2), DIMENSION(mp,0:ms+1) :: diff 
   REAL(r_2), DIMENSION(mp)      :: xx,xxd,evap_cur
   REAL(r_2), DIMENSION(mp,ms) :: zse_mp_mm
   INTEGER :: k,i

   CALL point2constants( C ) 

   do k=1,ms
      do i=1,mp
         zse_mp_mm(i,k)  = soil%zse_vec(i,k)*real(C%density_liq,r_2)
      end do
   end do

   IF (cable_user%FWSOIL_switch.ne.'Haverd2013') THEN
 
      xx(:) = 0._r_2
      xxd(:) = 0._r_2
      diff(:,:) = 0._r_2
   
      DO k = 1,ms  
   
         DO i=1,mp
   
            if (canopy%fevc(i) .gt. 0._r_2) then
   
               xx(i) = canopy%fevc(i) * dels / C%HL * veg%froot(i,k) + diff(i,k-1)
               diff(i,k) = max(0._r_2,ssnow%wbliq(i,k)-soil%swilt_vec(i,k)) &
                          * zse_mp_mm(i,k)
               xxd(i) = xx(i) - diff(i,k)
   
               if (xxd(i) .gt. 0._r_2) then
                  ssnow%wbliq(i,k) = ssnow%wbliq(i,k) - diff(i,k)/zse_mp_mm(i,k)
                  diff(i,k) = xxd(i)
               else
                  ssnow%wbliq(i,k) = ssnow%wbliq(i,k) - xx(i)/zse_mp_mm(i,k)
                  diff(i,k) = 0._r_2
               end if
   
   
             end if  !fvec > 0
   
         END DO  !mp
      END DO     !ms

   ELSE

     WHERE (canopy%fevc .lt. 0.0_r_2)
        canopy%fevw = canopy%fevw+canopy%fevc
        canopy%fevc = 0.0_r_2
     END WHERE
     DO k = 1,ms 
        ssnow%wbliq(:,k) = ssnow%wbliq(:,k) - ssnow%evapfbl(:,k)/zse_mp_mm(:,k)
     ENDDO

  ENDIF

  do k=1,ms
     do i=1,mp
        ssnow%wmliq(i,k) = ssnow%wbliq(i,k)*zse_mp_mm(i,k)!mass
        ssnow%wmtot(i,k) = ssnow%wmliq(i,k) + ssnow%wmice(i,k)  !mass
        ssnow%wb(i,k)    = ssnow%wbliq(i,k) + ssnow%wbice(i,k)  !volume
     end do
  end do


END SUBROUTINE remove_transGW


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 

!!!!!!!!!!!!!!MD GW code from here on!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   
  !-------------------------------------------------------------------------
  SUBROUTINE ovrlndflx (dels, ssnow, soil,veg, canopy,sli_call )
  USE cable_common_module, ONLY : gw_params,cable_user

  IMPLICIT NONE
    REAL, INTENT(IN)                         :: dels ! integration time step (s)
    TYPE(soil_snow_type), INTENT(INOUT)      :: ssnow  ! soil+snow variables
    TYPE(soil_parameter_type), INTENT(INOUT)    :: soil ! soil parameters
    TYPE(veg_parameter_type) , INTENT(INOUT)    :: veg  ! veg parameters
    TYPE (canopy_type), INTENT(INOUT)           :: canopy
    LOGICAL, INTENT(IN)                      :: sli_call
    INTEGER                                  :: nglacier ! 0 original, 1 off, 2 new Eva
    INTEGER                                  :: k, i, j
    REAL, DIMENSION(mp)                :: rnof5
    REAL, DIMENSION(mp)                :: sgamm
    REAL, DIMENSION(mp)                :: smasstot
    REAL, DIMENSION(mp,0:3)            :: smelt1                   !snow melt
    REAL(r_2), DIMENSION(mp)           :: icef,efpor               !tmp vars, fraction of ice in gridcell
    REAL(r_2)                          :: tmpa,tmpb,qinmax         !tmp vars, maximum infiltration [mm/s]
    REAL(r_2), DIMENSION(mp)           :: satfrac_liqice,S       !saturated fraction of cell, wtd in m
    REAL(r_2)                          :: liqmass,icemass,totmass  !liquid mass,ice mass, total mass [mm]
    REAL(r_2), parameter               :: pi=3.1415926535898
    REAL(r_2)                          :: fice
    REAL(r_2)                          :: dzmm,slopeSTDmm

   CALL point2constants( C ) 
    
   !For now assume there is no puddle

   if (mp .ge. 1) then
      dzmm = 1000._r_2 * soil%zse_vec(1,1)
   else
      dzmm = 1000._r_2 * real(soil%zse(1),r_2)
   end if

   if (sli_call) then
      do i=1,mp
         if (canopy%through(i) .ge. canopy%through_sn(i)) then
           ssnow%fwtop(i)  = max((canopy%through(i)-canopy%through_sn(i))/dels , 0.)             ! liq precip rate (m s-1)
         else
           ssnow%fwtop(i) = max(canopy%through(i), 0.)
         end if
      end do
   end if
   !amount of ice in surface layer
   do i = 1,mp
      efpor(i) = max(0.001_r_2, soil%ssat_vec(i,1) - ssnow%wbice(i,1))
      icemass  = ssnow%wbice(i,1) * dzmm * dri
      liqmass  = (ssnow%wb(i,1)-ssnow%wbice(i,1)) * dzmm
      totmass  = max(liqmass+icemass,real(1e-2,r_2))
      icef(i)     = max(0._r_2,min(1._r_2,gw_params%IceBeta*icemass / totmass))
   end do

   !sat fraction assuming topo controlled subgrid soil moisture distribution
   call saturated_fraction(ssnow,soil)

   !srf frozen fraction.  should be based on topography
   do i = 1,mp
      fice = (exp(-gw_params%IceAlpha*(1._r_2-icef(i)))-exp(-gw_params%IceAlpha))/(1._r_2-exp(-gw_params%IceAlpha))
      fice  = min(max(fice,0._r_2),1._r_2)
      satfrac_liqice(i)   = max(0.,min(0.95,fice + (1._r_2-fice)*ssnow%satfrac(i) ) )
   end do

   do i=1,mp
      tmpa = ssnow%wbliq(i,1) / efpor(i)
      tmpb = max( (tmpa-satfrac_liqice(i))/max(0.01_r_2,(1._r_2-satfrac_liqice(i))), 0._r_2)
      tmpa = -2._r_2*soil%bch_vec(i,1)*soil%sucs_vec(i,1)/dzmm
      qinmax = (1._r_2 + tmpa*(tmpb-1._r_2))*soil%hyds_vec(i,1)*exp(-gw_params%hkrz*(0.5*dzmm/1000.0_r_2-gw_params%zdepth))

      ssnow%rnof1(i) = satfrac_liqice(i) * ssnow%fwtop(i) + &
                         (1._r_2-satfrac_liqice(i))*max((ssnow%fwtop(i)-qinmax) , 0._r_2)

      ssnow%fwtop(i) = ssnow%fwtop(i) - ssnow%rnof1(i)

   end do  !mp

  !add back to the lakes to keep saturated instead of drying
  do i=1,mp
     if (veg%iveg(i) .eq. 16) then
        ssnow%fwtop(i) = ssnow%fwtop(i) + ssnow%rnof1(i)
        ssnow%rnof1(i) = 0._r_2
     end if
  end do
           
   !---  glacier formation
   rnof5= 0.

   if (sli_call) then
      nglacier = 0
   else
     nglacier = 2
   end if

   IF (nglacier == 2) THEN
      smelt1=0.
      WHERE( ssnow%snowd > max_glacier_snowd )

         rnof5 = MIN( 0.1, ssnow%snowd - max_glacier_snowd )

         !---- change local tg to account for energy - clearly not best method
         WHERE( ssnow%isflag == 0 )
            smasstot = 0.0
            ssnow%tgg(:,1) = ssnow%tgg(:,1) - rnof5 * C%HLF                    &
                             / REAL( ssnow%gammzz(:,1) )
            ssnow%snowd = ssnow%snowd - rnof5
         ELSEWHERE
            smasstot = ssnow%smass(:,1) + ssnow%smass(:,2) + ssnow%smass(:,3)
         END WHERE

      END WHERE

      DO k = 1, 3
         
         WHERE( ssnow%snowd > max_glacier_snowd  .AND.  ssnow%isflag > 0 )
            sgamm = ssnow%ssdn(:,k) * cgsnow * ssnow%sdepth(:,k)
            smelt1(:,k) = MIN( rnof5 * ssnow%smass(:,k) / smasstot,            &
                          0.2 * ssnow%smass(:,k) )
            ssnow%smass(:,k) = ssnow%smass(:,k) - smelt1(:,k)
            ssnow%snowd = ssnow%snowd - smelt1(:,k)
         END WHERE
      
      END DO
   
      WHERE( ssnow%isflag > 0 ) rnof5 = smelt1(:,1) + smelt1(:,2) + smelt1(:,3)

      ssnow%rnof1 = ssnow%rnof1 + rnof5/dels   !include this runoff in suface runoff term
   
   END IF

  END SUBROUTINE ovrlndflx




!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
  SUBROUTINE explicit_wtd(dels,ssnow, soil, veg, wtd_lev)
  !This was only for testing purposes
  IMPLICIT NONE
  REAL, INTENT(IN)                          :: dels
  TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
  TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
  TYPE (veg_parameter_type), INTENT(INOUT)     :: veg
  integer, intent(out), dimension(mp) :: wtd_lev

  REAL(r_2), DIMENSION(mp)            :: fz, wmean,ztot,zimm_ms,old_wtd
  REAL(r_2), DIMENSION(mp,0:ms+1)         :: znode_mm,dzmm
  REAL(r_2) :: Sy
  INTEGER                             :: k,i

  znode_mm(:,:) = 0._r_2
  znode_mm(:,1) = real(0.5*(soil%zse_vec(i,1) ),r_2)*1000._r_2

  dzmm(:,:) = soil%zse_vec*1000._r_2
  do k=2,ms
     do i=1,mp
        znode_mm(i,k) = znode_mm(i,k-1) + &
                        1000._r_2*real(0.5*(soil%zse_vec(i,k-1)+&
                                            soil%zse_vec(i,k)),r_2 )
     end do
  end do

  do i=1,mp
     zimm_ms(i) = znode_mm(i,ms) + 0.5*soil%zse_vec(i,ms)*1000._r_2
  end do

! wtd_lev(:) = ms+1
!  do k=1,ms
!     do i=1,mp
!        if (ssnow%wtd(i) .ge. (znode_mm(i,k) - 0.5*znode_mm(i,k)) .and.
!            ssnow%wtd(i) .lt. (znode_mm(i,k) + 0.5*znode_mm(i,k))) then
!           wtd_lev(i) = k
!         end if
!      end do
!   end do

 !all layers in column below wtd_lev are saturated
! wtd_lev(:) = ms+1
!  do k=1,ms
!     do i=1,mp
!        if (all(ssnow%wb(i,k:ms) .ge. 0.995*soil%ssat_vec(i,k:ms)) then
!           wtd_lev(i) = k
!         end if
!      end do
!   end do

   do i=1,mp

      if (ssnow%GWwb(i) .lt. 0.995*soil%GWssat(i)) then

         wtd_lev(i) = ms+1

      else

         do k=ms,1,-1

           if (ssnow%wb(i,k) .lt. 0.99*soil%ssat_vec(i,k) .and. k.eq.ms) then

              wtd_lev(i) = k

           elseif (k .ge. 2 .and. ssnow%wb(i,k) .ge. 0.99*soil%ssat_vec(i,k) .and.  &
               ssnow%wb(i,max(1,k-1)) .le. 0.9*soil%ssat_vec(i,max(1,k-1))) then 

               wtd_lev(i) = k - 1

           elseif (k .eq. 1) then

              wtd_lev(i) = k

           end if

         end do

      end if

    end do


   old_wtd = ssnow%wtd
   CALL iterative_wtd (ssnow, soil, veg, .true. ,wtd_lev)  

  do i=1,mp
     if (wtd_lev(i) .le. ms) then
         k = wtd_lev(i)
         !this is diagnosed
         !ssnow%Qrecharge(i) = (1.-ssnow%fracice(i,k))*ssnow%hk(i,k)*&
         !                     (0._r_2 - ssnow%smp(i,k)) / &
         !                      max(5._r_2,(ssnow%wtd(i)-znode_mm(i,k)-0.5*znode_mm(i,k)))

         Sy = soil%ssat_vec(i,k)*(1. - (1. + &
                (ssnow%wtd(i)/abs(soil%sucs_vec(i,k))))**&
                (-1.0/soil%bch_vec(i,k)) ) 

         !ssnow%wtd(i) = ssnow%wtd(i) + dels*(ssnow%Qrecharge(i) - ssnow%qhz(i))/Sy

         ssnow%Qrecharge(i) = (ssnow%wtd(i)-old_wtd(i))/dels*Sy + ssnow%qhz(i)

      else

       ssnow%Qrecharge(i) = -0.5*(ssnow%hk(i,ms)+ &
                                soil%GWhyds(i)*(1.0-ssnow%fracice(i,ms) ))*&
                               ((0._r_2-ssnow%smp(i,ms)) -&
                                (ssnow%GWzq(i)-zimm_ms(i))) / &
                                max(5._r_2,(ssnow%wtd(i) -zimm_ms(i)))
         
     end if

  end do


  END SUBROUTINE explicit_wtd
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  


  !----------------------------------------------------------------------
  ! SUBROUTINE iterative_wtd
  !
  ! Iteratively calcs the water table depth by equating the mass of water in the
  ! soil column to the mass of a hydrostatic column inegrated from the surface to the 
  ! water table depth
  !  
  SUBROUTINE iterative_wtd (ssnow, soil, veg, include_aquifer,klev)
  IMPLICIT NONE
  TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
  TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
  TYPE (veg_parameter_type), INTENT(INOUT)     :: veg
  LOGICAL, INTENT(IN)                       :: include_aquifer  !use GWwb or only wb to find wtd?
  INTEGER, DIMENSION(MP), INTENT(IN)        :: klev
 
  !Local vars 
  REAL(r_2), DIMENSION(mp,ms)   :: dzmm_mp,tmp_def
  REAL(r_2), DIMENSION(mp,0:ms+1)    :: zimm
  REAL(r_2), DIMENSION(ms)      :: zmm
  REAL(r_2), DIMENSION(mp)      :: GWzimm,temp
  REAL(r_2), DIMENSION(mp)      :: def,defc,total_depth_column

  REAL(r_2)                     :: deffunc,tempa,tempb,derv,calc,tmpc
  REAL(r_2), DIMENSION(mp)      :: invB,Nsucs_vec,ssatV
  INTEGER :: k,i,wttd,jlp

  !make code cleaner define these here 
  !dzmm_mp  = real(spread((soil%zse(:)) * 1000.0,1,mp),r_2)    !layer thickness mm
  dzmm_mp  = soil%zse_vec*1000.0_r_2  !layer thickness mm
  zimm(:,:)  = 0.0_r_2                                          !depth of layer interfaces mm
  do k=1,ms
     do i=1,mp
        zimm(i,k) = zimm(i,k-1) + soil%zse_vec(i,k)*1000._r_2
     end do
  end do

  k=ms+1
  do i=1,mp
    zimm(i,k) = zimm(i,k-1) + soil%GWdz(i)*1000._r_2
  end do

  !total depth of soil column

  DO i=1,mp
     IF (klev(i) .lt. 0) THEN

        invB(i)     = 1._r_2/soil%bch_vec(i,ms)                                !1 over C&H B
        Nsucs_vec(i)  = soil%sucs_vec(i,ms)                                !psi_saturated mm
        ssatV(i) = soil%ssat_vec(i,ms)


        def(i) = 0._r_2
        total_depth_column(i) = zimm(i,ms)

         if (include_aquifer) then  !do we include the aquifer in the calculation of wtd?
       
           total_depth_column(i) = zimm(i,ms+1)
           def(i) = def(i) + max(0._r_2,soil%GWssat(i)-ssnow%GWwb(i))*soil%GWdz(i)*1000._r_2
       
         end if

         !comute the total mass away from full saturation
         do k=1,ms

           def(i) = def(i) +                                                           &
                    max(0._r_2,(soil%ssat_vec(i,k)-(ssnow%wbliq(i,k)+dri*ssnow%wbice(i,k)))*dzmm_mp(i,k))
         end do  !ms

    ELSEIF (klev(i) .le. ms) THEN

     k = klev(i)
     invB(i)     = 1._r_2/soil%bch_vec(i,k)                                !1 over C&H B
     Nsucs_vec(i)  = soil%sucs_vec(i,k)                                !psi_saturated mm
     ssatV(i) = soil%ssat_vec(i,k)

      total_depth_column(i) = 1000.0*soil%zse_vec(i,k)
      def(i) = max(0._r_2,&
               (soil%ssat_vec(i,k)-(ssnow%wbliq(i,k)+&
                dri*ssnow%wbice(i,k)))*dzmm_mp(i,k))


     ELSE
        invB(i)     = 1._r_2/soil%GWbch(i)
        Nsucs_vec(i)  = soil%GWsucs(i)
    
        total_depth_column(i) = 1000.0*soil%GWdz(i)
        def(i) = max(0._r_2,&
                 (soil%GWssat(i)-(ssnow%GWwb(i)))*soil%GWdz(i)*1000._r_2)

         ssatV(i) = soil%GWssat(i)

     ENDIF

  !find the deficit if the water table is at the bottom of the soil column
     defc(i) = (ssatV(i))*(total_depth_column(i)+Nsucs_vec(i)/(1._r_2-invB(i))*     &
             (1._r_2-((Nsucs_vec(i)+total_depth_column(i))/Nsucs_vec(i))**(1._r_2-invB(i)))) 
     defc(i) = max(0.001_r_2,defc(i)) 

     !initial guess at wtd
     ssnow%wtd(:) = total_depth_column(:)*def(:)/defc(:)
  end do


 !use newtons method to solve for wtd, note this assumes homogenous column but
 !that is ok 
  do i=1,mp
    if ((soil%isoilm(i) .ne. 9) .and. (veg%iveg(i) .ne. 16)) then      

      if (defc(i) > def(i)) then                 !iterate tfor wtd

        jlp=0

        mainloop: DO

          tempa   = 1.0_r_2
          tempb   = (1._r_2+ssnow%wtd(i)/Nsucs_vec(i))**(-invB(i))
          derv    = (ssatV(i))*(tempa-tempb) + ssatV(i)

          if (abs(derv) .lt. real(1e-8,r_2)) derv = sign(real(1e-8,r_2),derv)

          tempa   = 1.0_r_2
          tempb   = (1._r_2+ssnow%wtd(i)/Nsucs_vec(i))**(1._r_2-invB(i))
          deffunc = (ssatV(i))*(ssnow%wtd(i) +&
                           Nsucs_vec(i)/(1-invB(i))* &
                     (tempa-tempb)) - def(i)
          calc    = ssnow%wtd(i) - deffunc/derv

          IF ((abs(calc-ssnow%wtd(i))) .le. wtd_uncert) THEN

            ssnow%wtd(i) = calc
            EXIT mainloop

          ELSEIF (jlp .ge. wtd_iter_max) THEN

            EXIT mainloop

          ELSE

            jlp=jlp+1
            ssnow%wtd(i) = calc

          END IF

        END DO mainloop  !defc .gt. def

      elseif (defc(i) .lt. def(i)) then

        jlp=0

        mainloop2: DO

          tmpc     = Nsucs_vec(i)+ssnow%wtd(i)-total_depth_column(i)
          tempa    = (abs(tmpc/Nsucs_vec(i)))**(-invB(i))
          tempb    = (1._r_2+ssnow%wtd(i)/Nsucs_vec(i))**(-invB(i))
          derv     = (ssatV(i))*(tempa-tempb)
          if (abs(derv) .lt. real(1e-8,r_2)) derv = sign(real(1e-8,r_2),derv)

          tempa    = (abs((Nsucs_vec(i)+ssnow%wtd(i)-total_depth_column(i))/Nsucs_vec(i)))**(1._r_2-invB(i))
          tempb    = (1._r_2+ssnow%wtd(i)/Nsucs_vec(i))**(1._r_2-invB(i))
          deffunc  = (ssatV(i))*(total_depth_column(i) +&
                     Nsucs_vec(i)/(1._r_2-invB(i))*(tempa-tempb))-def(i)
          calc     = ssnow%wtd(i) - deffunc/derv

          IF ((abs(calc-ssnow%wtd(i))) .le. wtd_uncert) THEN

            ssnow%wtd(i) = calc
            EXIT mainloop2

          ELSEIF (jlp==wtd_iter_max) THEN

            EXIT mainloop2

          ELSE

            jlp=jlp+1
            ssnow%wtd(i) = calc

          END IF

        END DO mainloop2  !defc .lt. def

      else  !water table depth is exactly on bottom boundary

        ssnow%wtd(i) = total_depth_column(i)

      endif

    endif  !check veg and soils

  end do   !mp loop


  !limit wtd to be within a psecified range
  do i=1,mp
     if (klev(i) .gt. 0) then
        ssnow%wtd(i) = min(wtd_max,max(wtd_min,ssnow%wtd(i) + zimm(i,k-1)))
     else
        ssnow%wtd(i) = min(wtd_max,max(wtd_min,ssnow%wtd(i) ) )
     endif
  end do


  END SUBROUTINE iterative_wtd

  !-------------------------------------------------------------------------
  ! SUBROUTINE smoistgw (fwtop,dt,ktau,ssnow,soil,prin)
  ! solves the modified richards equation (Zeng and Decker 2009) to find
  ! vertical mocement of soil water.  Bottom boundary condition is determined
  ! using a single layer groundwater module
  !
  SUBROUTINE smoistgw (dels,ktau,ssnow,soil,veg,canopy)
  USE cable_common_module

  IMPLICIT NONE
  
    REAL, INTENT(IN)                          :: dels  ! time step size (s)
    INTEGER, INTENT(IN)                       :: ktau  ! integration step number
    TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
    TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
    TYPE (veg_parameter_type), INTENT(INOUT)     :: veg
    TYPE(canopy_type), INTENT(INOUT)          :: canopy ! vegetation variables
    
    !Local variables.  
    REAL(r_2), DIMENSION(mp,ms+1)       :: at     ! coef "A" in finite diff eq
    REAL(r_2), DIMENSION(mp,ms+1)       :: bt     ! coef "B" in finite diff eq
    REAL(r_2), DIMENSION(mp,ms+1)       :: ct     ! coef "C" in finite diff eq
    REAL(r_2), DIMENSION(mp,ms+1)       :: rt

    INTEGER                             :: k,kk,i
    REAL(r_2), DIMENSION(mp,ms)         :: eff_por,old_wb  !effective porosity (mm3/mm3),wb(mm3/mm3),mass (mm) of eff_por
    REAL(r_2), DIMENSION(mp,ms)         :: msliq,msice             !mass of the soil liquid and ice water    
    REAL(r_2), DIMENSION(mp)            :: den
    REAL(r_2), DIMENSION(mp)            :: dne
    REAL(r_2), DIMENSION(mp)            :: num
    REAL(r_2), DIMENSION(mp)            :: qin
    REAL(r_2), DIMENSION(mp)            :: qout
    REAL(r_2), DIMENSION(mp)            :: dqidw0
    REAL(r_2), DIMENSION(mp)            :: dqidw1
    REAL(r_2), DIMENSION(mp)            :: dqodw0
    REAL(r_2), DIMENSION(mp)            :: dqodw1,dqodw2
    REAL(r_2), DIMENSION(mp)            :: s1,s2,tmpi,temp0,voleq1,tempi
    REAL(r_2), DIMENSION(mp,ms)         :: dzmm
    REAL(r_2), DIMENSION(mp,0:ms+1)        :: zimm
    REAL(r_2), DIMENSION(mp,ms)            :: zmm
    REAL(r_2), DIMENSION(mp)            :: GWzimm,xs,zaq,s_mid,GWdzmm
    REAL(r_2), DIMENSION(mp)            :: xs1,GWmsliq!xsi    !mass (mm) of liquid over/under saturation, mass of aquifer water
    REAL(r_2)                           :: xsi
    REAL(r_2), DIMENSION(mp,ms+1)       :: del_wb
    !MD DEBUG VARS
    INTEGER :: imp,ims,k_drain
    INTEGER, DIMENSION(mp) :: wtd_lev

    !make code cleaner define these here
    dzmm(:,:) = soil%zse_vec*1000._r_2

    zimm(:,0) = 0._r_2
    zimm(:,1:ms) = zimm(:,0:(ms-1)) + dzmm(:,1:ms)
    zmm(:,1:ms)  = zimm(:,0:(ms-1)) + 0.5_r_2*dzmm(:,1:ms)

    do i=1,mp
       GWdzmm(i) = real(soil%GWdz(i),r_2)*1000._r_2
       GWzimm(i) = zimm(i,ms)+GWdzmm(i)
       zaq(i)    = zimm(i,ms) + 0.5_r_2*GWdzmm(i)
    end do
    ssnow%GWzaq(:) = zaq(:)
    
    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    ! preset to allow for non-land & snow points in trimb
    do k=1,ms
       do i=1,mp
          old_wb(i,k) = ssnow%wb(i,k)
          rt(i,k) = 0._r_2
          at(i,k) = 0._r_2
          bt(i,k) = 0._r_2
          ct(i,k) = 0._r_2
       end do
    end do
    
    !equilibrium water content
    CALL calc_equilibrium_water_content(ssnow,soil)

    CALL calc_soil_hydraulic_props(ssnow,soil,veg)

    if (.not.cable_user%super_hydro)   then
    CALL subsurface_drainage(ssnow,soil,veg,dzmm)
    else
       ssnow%qhlev(:,:) = 0.
    end if

    k = 1     !top soil layer
    do i=1,mp
       qin(i)     = ssnow%sinfil(i)
       den(i)     = (zmm(i,k+1)-zmm(i,k))
       dne(i)     = (ssnow%zq(i,k+1)-ssnow%zq(i,k))
       num(i)     = (ssnow%smp(i,k+1)-ssnow%smp(i,k)) - dne(i)
       qout(i)    = -ssnow%hk(i,k)*num(i)/den(i)
       dqodw1(i)  = -(-ssnow%hk(i,k)*ssnow%dsmpdw(i,k)   + num(i)*ssnow%dhkdw(i,k))/den(i)
       dqodw2(i)  = -( ssnow%hk(i,k)*ssnow%dsmpdw(i,k+1) + num(i)*ssnow%dhkdw(i,k))/den(i)
       rt(i,k) =  qin(i) - qout(i)
       at(i,k) =  0._r_2
       bt(i,k) =  dzmm(i,k)/dels + dqodw1(i)
       ct(i,k) =  dqodw2(i)      
    end do
    do k = 2, ms - 1     !middle soil layers
       do i=1,mp
          den(i)     = (zmm(i,k) - zmm(i,k-1))
          dne(i)     = (ssnow%zq(i,k)-ssnow%zq(i,k-1))
          num(i)     = (ssnow%smp(i,k)-ssnow%smp(i,k-1)) - dne(i)
          qin(i)     = -ssnow%hk(i,k-1)*num(i)/den(i)
          dqidw0(i)  = -(-ssnow%hk(i,k-1)*ssnow%dsmpdw(i,k-1) + num(i)*ssnow%dhkdw(i,k-1))/den(i)
          dqidw1(i)  = -( ssnow%hk(i,k-1)*ssnow%dsmpdw(i,k)   + num(i)*ssnow%dhkdw(i,k-1))/den(i)
          den(i)     = (zmm(i,k+1)-zmm(i,k))
          dne(i)     = (ssnow%zq(i,k+1)-ssnow%zq(i,k))
          num(i)     = (ssnow%smp(i,k+1)-ssnow%smp(i,k)) - dne(i)
          qout(i)    = -ssnow%hk(i,k)*num(i)/den(i)
          dqodw1(i)  = -(-ssnow%hk(i,k)*ssnow%dsmpdw(i,k)   + num(i)*ssnow%dhkdw(i,k))/den(i)
          dqodw2(i)  = -( ssnow%hk(i,k)*ssnow%dsmpdw(i,k+1) + num(i)*ssnow%dhkdw(i,k))/den(i)
          rt(i,k) =  qin(i) - qout(i)
          at(i,k) = -dqidw0(i)
          bt(i,k) =  dzmm(i,k)/dels - dqidw1(i) + dqodw1(i)
          ct(i,k) =  dqodw2(i)
       end do
    end do
       
    k = ms   !Bottom soil layer
    do i=1,mp
       den(i)     = (zmm(i,k) - zmm(i,k-1))
       dne(i)     = (ssnow%zq(i,k)-ssnow%zq(i,k-1))
       num(i)     = (ssnow%smp(i,k)-ssnow%smp(i,k-1)) - dne(i)
       qin(i)     = -ssnow%hk(i,k-1)*num(i)/den(i)
       dqidw0(i)  = -(-ssnow%hk(i,k-1)*ssnow%dsmpdw(i,k-1) + num(i)*ssnow%dhkdw(i,k-1))/den(i)
       dqidw1(i)  = -( ssnow%hk(i,k-1)*ssnow%dsmpdw(i,k)   + num(i)*ssnow%dhkdw(i,k-1))/den(i)
       den(i)     = ssnow%GWzaq(i) - zmm(i,k)
       dne(i)     = (ssnow%GWzq(i)-ssnow%zq(i,k))
       num(i)     =  (0._r_2-ssnow%smp(i,k)) - dne(i)
       qout(i)    = 0._r_2
       dqodw1(i)  = 0._r_2
       dqodw2(i)  = 0._r_2
       rt(i,k) =  qin(i) - qout(i)
       at(i,k) = -dqidw0(i)
       bt(i,k) =  dzmm(i,k)/dels - dqidw1(i) + dqodw1(i)
       ct(i,k) =  dqodw2(i) 
    end do
      
    if (.not.cable_user%super_hydro) then 
       CALL aquifer_recharge(dels,ssnow,soil,veg,zmm,dzmm)
    else
       call explicit_wtd(dels,ssnow, soil, veg, wtd_lev)
    end if

    CALL trimb(at,bt,ct,rt,ms)                       !use the defulat cable tridiag solution

    do k=1,ms
       do i=1,mp
          ssnow%wbliq(i,k) = ssnow%wbliq(i,k) + rt(i,k) - ssnow%qhlev(i,k)*dels/dzmm(i,k)   !volutermic liquid
       end do
    end do

    if (.not.cable_user%super_hydro) then

       do i=1,mp
          ssnow%wbliq(i,ms) = ssnow%wbliq(i,ms) - ssnow%Qrecharge(i)*dels/dzmm(i,ms)
          ssnow%GWwb(i) = ssnow%GWwb(i)  +  (ssnow%Qrecharge(i)-ssnow%qhlev(i,ms+1))*dels/GWdzmm(i)
       end do

    else

       do i=1,mp
          if (wtd_lev(i) .eq. ms+1) then
             ssnow%wbliq(i,ms) = ssnow%wbliq(i,ms) - ssnow%Qrecharge(i)*dels/dzmm(i,ms)
             ssnow%GWwb(i) = ssnow%GWwb(i)  +  (ssnow%Qrecharge(i)-ssnow%qhlev(i,ms+1))*dels/GWdzmm(i)
           else
             ssnow%GWwb(i) = ssnow%GWwb(i)  +  (0._r_2-ssnow%qhlev(i,ms+1))*dels/GWdzmm(i)
           end if
       end do

    end if

    !determine the available pore space
    !volumetric
    do k=1,ms
       do i=1,mp
          eff_por(i,k)  = soil%ssat_vec(i,k) - ssnow%wbice(i,k)
       end do
    end do

    do i=1,mp
       xsi = 0._r_2

       if (ssnow%GWwb(i) .gt. soil%GWssat(i)) then
          xsi = (ssnow%GWwb(i) - soil%GWssat(i))*GWdzmm(i)
          ssnow%GWwb(i) = soil%GWssat(i)
       end if

       do k=1,ms
          if (ssnow%wbliq(i,k) .gt. eff_por(i,k)) then
             xsi = xsi + (ssnow%wbliq(i,k) - eff_por(i,k))*dzmm(i,k)
             ssnow%wbliq(i,k) = eff_por(i,k)
           end if
       end do
     
       do k = ms,1,-1  !loop from bottom to top adding extra water to each layer
          if (xsi .gt. 0._r_2) then
             if (xsi .lt. (eff_por(i,k)-ssnow%wbliq(i,k))*dzmm(i,k)) then
                ssnow%wbliq(i,k) = ssnow%wbliq(i,k) + xsi/dzmm(i,k)
                xsi = 0._r_2
             else
                xsi = xsi - (eff_por(i,k) - ssnow%wbliq(i,k))*dzmm(i,k)
                ssnow%wbliq(i,k) = eff_por(i,k)
             end if
          end if
       end do  !ms loop

       if (xsi .gt. 0._r_2) then
          ssnow%qhz(i) = ssnow%qhz(i) + xsi/dels
          xsi = 0._r_2
       end if

       do k = 1,ms
          xsi = 0._r_2             !should be a single float (array not needed)
          if (ssnow%wbliq(i,k) .lt. volwatmin) then
             xsi = (volwatmin - ssnow%wbliq(i,k))*dzmm(i,k)  !in mm
             ssnow%wbliq(i,k) = volwatmin
             if (k .lt. ms) then
                ssnow%wbliq(i,k+1) = ssnow%wbliq(i,k+1) - xsi/dzmm(i,k+1)
             else
                ssnow%GWwb(i) = ssnow%GWwb(i) - xsi / GWdzmm(i)
             end if
          end if
       end do  !ms loop
 
       if ( (ssnow%GWwb(i) .lt. volwatmin) .and. (soil%isoilm(i) .ne. 9) ) then
          xsi = (volwatmin - ssnow%GWwb(i)) / GWdzmm(i)  !mm
          ssnow%GWwb(i) = volwatmin
          ssnow%qhz(i) = ssnow%qhz(i) - xsi / dels
       end if

   end do

   do k=1,ms
      do i=1,mp
         
       !update mass variables
         ssnow%wmliq(i,k)      = ssnow%wbliq(i,k) * soil%zse_vec(i,k)*real(C%density_liq,r_2)
         ssnow%wmice(i,k)      = ssnow%wbice(i,k) * soil%zse_vec(i,k)*real(C%density_ice,r_2)
         ssnow%wb(i,k)         = ssnow%wbliq(i,k) + ssnow%wbice(i,k)
         ssnow%wmtot(i,k)      = ssnow%wmliq(i,k) + ssnow%wmice(i,k)
      end do
   end do

   do i=1,mp
       ssnow%rnof2(i)        = ssnow%qhz(i)               !rnof2 is default cable deep runoff var 
   end do  !mp loop
       

 END SUBROUTINE smoistgw



! Inputs:
!	 dt_in - time step in sec
!	 ktau_in - time step no.
!	 ga	 - ground heat flux W/m^2
!	 dgdtg	 -
!	 condxpr - total precip reaching the ground (liquid and solid)
!	 scondxpr - precip (solid only)
!	 fev   - transpiration (W/m2)
!	 fes   - soil evaporation (W/m2)
!	 isoil - soil type
!	 ivegt - vegetation type
! Output
!	 ssnow
SUBROUTINE soil_snow_gw(dels, soil, ssnow, canopy, met, bal, veg)
   USE cable_IO_vars_module, ONLY: wlogn

   USE cable_common_module
   REAL                     , INTENT(IN)     :: dels ! integration time step (s)
   TYPE(soil_parameter_type), INTENT(INOUT)  :: soil
   TYPE(soil_snow_type)     , INTENT(INOUT)  :: ssnow
   TYPE(canopy_type)        , INTENT(INOUT)  :: canopy
   TYPE(veg_parameter_type) , INTENT(INOUT)  :: veg
   TYPE(met_type)           , INTENT(INOUT)  :: met ! all met forcing
   TYPE (balances_type)     , INTENT(INOUT)  :: bal

   INTEGER             :: k,i
   REAL, DIMENSION(mp) :: snowmlt
   REAL, DIMENSION(mp) :: GWwb_ic
   REAL, DIMENSION(mp) :: tgg_old, tggsn_old,wbtot_ic,del_wbtot
   REAL(r_2), DIMENSION(mp) :: xx
   REAL                :: zsetot
   INTEGER, SAVE :: ktau =0 
   REAL(r_2) :: wb_lake_T, rnof2_T
   LOGICAL :: use_sli
   LOGICAL, SAVE :: first_gw_hydro_call = .true.
   INTEGER, DIMENSION(mp) :: use_single_level
  
   use_single_level(:) = -1
   use_sli = .false. 

   CALL point2constants( C ) 
    
   ktau = ktau +1 

   
   zsetot = sum(soil%zse) 
   ssnow%tggav = 0.

   DO k = 1, ms

      ssnow%tggav = ssnow%tggav  + soil%zse(k)*ssnow%tgg(:,k)/zsetot

   END DO


   IF( cable_runtime%offline .or. cable_runtime%mk3l ) ssnow%t_snwlr = 0.05_r_2

   do i=1,mp
      ssnow%fwtop1(i) = 0.0
      ssnow%fwtop2(i) = 0.0
      ssnow%fwtop3(i) = 0.0
      ssnow%runoff(i) = 0.0 ! initialise total runoff
      ssnow%rnof1(i) = 0.0 ! initialise surface runoff
      ssnow%rnof2(i) = 0.0 ! initialise deep drainage
      ssnow%smelt(i) = 0.0 ! initialise snowmelt
      ssnow%dtmlt(i,:) = 0.0 
      ssnow%osnowd(i) = ssnow%snowd(i)
      ! Scaling  runoff to kg/m^2/s (mm/s) to match rest of the model
      ssnow%sinfil(i) = 0.0   
   end do

   IF( (.NOT.cable_user%cable_runtime_coupled ) .and. (first_gw_hydro_call)) THEN
   
         IF (cable_runtime%um) canopy%dgdtg = 0.0 ! RML added um condition
                                                  ! after discussion with BP
         ! N.B. snmin should exceed sum of layer depths, i.e. .11 m
         ssnow%wbtot = 0.0
         ssnow%wb(:,:)  = MIN( soil%ssat_vec(:,:), MAX ( ssnow%wb(:,:), soil%swilt_vec(:,:) ) )   

         DO k = 1, ms
            
            WHERE( ssnow%tgg(:,k) <= C%TFRZ .AND. ssnow%wbice(:,k) <= 0.01 )   &
               ssnow%wbice(:,k) = 0.5 * ssnow%wb(:,k)

            WHERE( ssnow%tgg(:,k) < C%TFRZ)                                    &
               ssnow%wbice(:,k) = 0.8 * ssnow%wb(:,k)
            
         END DO

         WHERE ( soil%isoilm .eq. 9 ) 

            ! permanent ice: fix hard-wired number in next version
            ssnow%snowd = max_glacier_snowd
            ssnow%osnowd = max_glacier_snowd
            ssnow%tgg(:,1) = ssnow%tgg(:,1) - 1.0

         END WHERE

         WHERE ( spread(soil%isoilm,2,ms) .eq. 9 )

              ssnow%wb    = 0.95 * soil%ssat_vec
              ssnow%wbice = 0.90 * ssnow%wb

         END WHERE
         
         ssnow%gammzz(:,1) = MAX( (1.0 - soil%ssat_vec(:,1)) * soil%css_vec(:,1) * soil%rhosoil_vec(:,1) &
              & + (ssnow%wb(:,1) - ssnow%wbice(:,1) ) * cswat * C%density_liq &
              & + ssnow%wbice(:,1) * csice * C%density_ice, &
                  soil%css_vec(:,1) * soil%rhosoil_vec(:,1) ) * soil%zse_vec(:,1)

   ENDIF  ! if(.NOT.cable_runtime_coupled) and first_gw_hydro_call

   !Start with wb and wbice.  Need wbliq, wmliq,wmice,wmtot
   !find the mass of ice and liq from the prognostic volumetric values
   do k=1,ms
      do i=1,mp
         ssnow%wbliq(i,k) = ssnow%wb(i,k) - ssnow%wbice(i,k)                     !liquid volume
         ssnow%wmice(i,k) = ssnow%wbice(i,k)*real(C%density_ice*soil%zse_vec(i,k),r_2) !ice mass
         ssnow%wmliq(i,k) = ssnow%wbliq(i,k)*real(C%density_liq*soil%zse_vec(i,k),r_2) !liquid mass
         ssnow%wmtot(i,k) = ssnow%wmice(i,k) + ssnow%wmliq(i,k)                  !liq+ice mass
         ssnow%wblf(i,k)   = max(ssnow%wbliq(i,k)/soil%ssat_vec(i,k),0.01_r_2)
         ssnow%wbfice(i,k) = max(ssnow%wbice(i,k)/soil%ssat_vec(i,k),0._r_2)

      end do
   end do

   do i=1,mp
      IF (first_gw_hydro_call)                                                   &
        ssnow%gammzz(i,1) = MAX( &
                           (1.0 - soil%ssat_vec(i,1)) * soil%css_vec(i,1)*soil%rhosoil_vec(i,1)  &
            & + ssnow%wbliq(i,1) * cswat * C%density_liq           &
            & + ssnow%wbice(i,1) * csice * C%density_ice,&
            &  soil%css_vec(i,1)*soil%rhosoil_vec(i,1) ) * soil%zse_vec(i,1) +   &
            & (1. - ssnow%isflag(i)) * cgsnow * ssnow%snowd(i)

      !initial water in the soil column
      wbtot_ic(i)  = sum(ssnow%wbliq(i,:)*C%density_liq*soil%zse_vec(i,:),1) + &
                     sum(ssnow%wbice(i,:)*C%density_ice*soil%zse_vec(i,:),1) + &
                     ssnow%GWwb(i)*soil%GWdz(i)*C%density_liq
                  
      GWwb_ic(i) = ssnow%GWwb(i)

   end do

   CALL snowcheck (dels, ssnow, soil, met )

   CALL snowdensity (dels, ssnow, soil)

   CALL snow_accum (dels, canopy, met, ssnow, soil )

   CALL snow_melting (dels, snowmlt, ssnow, soil )

   ! Add snow melt to global snow melt variable:
   do i=1,mp
     ssnow%smelt(i) = snowmlt(i)
   end do
   ! Adjust levels in the snowpack due to snow accumulation/melting,
   ! snow aging etc...

   CALL snowl_adjust(dels, ssnow, canopy )

   CALL GWstempv(dels, canopy, ssnow, soil)

   !do the soil and snow melting, freezing prior to water movement
   do i=1,mp
      ssnow%tss(i) =  (1-ssnow%isflag(i))*ssnow%tgg(i,1) + ssnow%isflag(i)*ssnow%tggsn(i,1)
   end do

   CALL snow_melting (dels, snowmlt, ssnow, soil )
   
   ! Add new snow melt to global snow melt variable: 
   do i=1,mp
     ssnow%smelt(i) = ssnow%smelt(i) + snowmlt(i)
   end do

   CALL remove_transGW(dels, soil, ssnow, canopy, veg)        !transpiration loss per soil layer

   CALL  GWsoilfreeze(dels, soil, ssnow)

   ssnow%fwtop = canopy%precis/dels + ssnow%smelt/dels   !water from canopy and snowmelt [mm/s]   
   !ssnow%rnof1 = ssnow%rnof1 + ssnow%smelt / dels          !adding snow melt directly to the runoff

   if (first_gw_hydro_call) &
      CALL iterative_wtd (ssnow, soil, veg, .true. ,use_single_level)  

   CALL ovrlndflx (dels, ssnow, soil, veg, canopy,use_sli )         !surface runoff, incorporate ssnow%pudsto?

   ssnow%sinfil = ssnow%fwtop - canopy%segg  !canopy%fes/C%HL               !remove soil evap from throughfall

   CALL smoistgw (dels,ktau,ssnow,soil,veg,canopy)               !vertical soil moisture movement. 

   if (cable_user%super_hydro) then
      !calc explicit horz transfer and update the wtd
      call subgrid_sm_transfer(dels,ssnow,soil,veg)
   end if 

   !CALL iterative_wtd (ssnow, soil, veg, .true. )  

   ! correction required for energy balance in online simulations 
   IF( cable_runtime%um) THEN

      !cls package - rewritten for flexibility
      canopy%fhs_cor = ssnow%dtmlt(:,1)*ssnow%dfh_dtg
      !canopy%fes_cor = ssnow%dtmlt(:,1)*(ssnow%dfe_ddq * ssnow%ddq_dtg)
      canopy%fes_cor = ssnow%dtmlt(:,1)*ssnow%dfe_dtg

      canopy%fhs = canopy%fhs+canopy%fhs_cor
      canopy%fes = canopy%fes+canopy%fes_cor

      !REV_CORR associated changes to other energy balance terms
      !NB canopy%fns changed not rad%flws as the correction term needs to
      !pass through the canopy in entirety, not be partially absorbed
      IF (cable_user%L_REV_CORR) THEN
         canopy%fns_cor = ssnow%dtmlt(:,1)*ssnow%dfn_dtg
         canopy%ga_cor = ssnow%dtmlt(:,1)*canopy%dgdtg

         canopy%fns = canopy%fns + canopy%fns_cor
         canopy%ga = canopy%ga + canopy%ga_cor

         canopy%fess = canopy%fess + canopy%fes_cor
      ENDIF

   ENDIF

   do i=1,mp
      ssnow%smelt(i)  = ssnow%smelt(i)/dels    !change units to mm/s.  cable_driver then reverts back to mm
      ssnow%runoff(i) = (ssnow%rnof1(i) + ssnow%rnof2(i))!*dels  !cable_driver converts from mm/s to mm
                                                        !rnof1 and rnof2 are already in mm/s
      ! Set weighted soil/snow surface temperature
      ssnow%tss(i) =  (1-ssnow%isflag(i))*ssnow%tgg(i,1) + ssnow%isflag(i)*ssnow%tggsn(i,1)

      !total water mass at the end of the soilsnow_GW routine
      ssnow%wbtot(i)  = sum(ssnow%wbliq(i,:)*C%density_liq*soil%zse_vec(i,:),dim=1) + &
                     sum(ssnow%wbice(i,:)*C%density_ice*soil%zse_vec(i,:),dim=1) + &
                     ssnow%GWwb(i)*soil%GWdz(i)*C%density_liq
                    
      !for debug water balance.  del_wbtot = fluxes = infiltration [though-evap] - trans - qhorz drainage
      del_wbtot(i)   = dels * (ssnow%sinfil(i) - ssnow%rnof2(i) - canopy%fevc(i) / C%HL)
      !set below to keep track of water imbalance within the GW module explicitly.  also must change cable_checks
      ssnow%wbtot(i) = ssnow%wbtot(i)-wbtot_ic(i)

   end do

END SUBROUTINE soil_snow_gw


SUBROUTINE calc_equilibrium_water_content(ssnow,soil)
  !find layer mean soil moisture and potential at equilibrium with wtd

  IMPLICIT NONE
  
    TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
    TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
    !local variables
    REAL(r_2), dimension(mp)    :: zaq      !node depth of the aquifer
    REAL(r_2), dimension(mp,ms)    :: dzmm     !layer thickness for single tile
    REAL(r_2), dimension(mp)    :: GWdzmm   !aquifer thickness at each tile
    REAL(r_2), dimension(mp)    :: GWzimm   !aquifer layer interface depth
    REAL(r_2), dimension(mp,0:ms)  :: zimm     !layer interface depth in mm  
    REAL(r_2), dimension(mp,ms)    :: zmm      !node depths in mm
    REAL(r_2)                   :: tempi, temp0,voleq1,wbrat
    REAL(r_2), DIMENSION(mp,ms+1) :: ice_correction !correct calc if using liq water for potental and hk

    INTEGER :: k,i

    !make code cleaner define these here
    dzmm    = 1000.0_r_2 * real(soil%zse_vec(:,:),r_2)
    zimm(:,:) = 0._r_2

    do k=1,ms
       zimm(:,k) = zimm(:,k-1) + dzmm(:,k)
       zmm(:,k)  = zimm(:,k-1) + 0.5_r_2*dzmm(:,k)
    end do 

    do i=1,mp
       GWdzmm(i) = soil%GWdz(i)*1000._r_2
       GWzimm(i) = zimm(i,ms)+GWdzmm(i)
       ssnow%GWzaq(i)    = zimm(i,ms) + 0.5_r_2*GWdzmm(i)
    end do
    !equilibrium water content


    if (.not.gw_params%ssgw_ice_switch) then
       ice_correction(:,:) = 1._r_2

    else

    do k=1,ms
     do i=1,mp
       ice_correction(i,k)    = 1._r_2 + 8._r_2 * ssnow%wbice(i,k)
       ice_correction(i,k)    =  ice_correction(i,k)**(2.0/soil%bch_vec(i,k))
      end do
    end do
    do i=1,mp
       ice_correction(i,ms+1)    = 1._r_2 + 8._r_2 * ssnow%wbice(i,ms)
       ice_correction(i,ms+1)    =  ice_correction(i,ms+1)**(2.0/soil%GWbch(i))
    end do

    end if

    do k=1,ms
       do i=1,mp

          if ((ssnow%wtd(i) .le. zimm(i,k-1))) then         !fully saturated

             ssnow%wbeq(i,k) = soil%ssat_vec(i,k)
             
          elseif ((ssnow%wtd(i) .le. zimm(i,k)) .and. &
                  (ssnow%wtd(i) .gt. zimm(i,k-1))) then

             tempi = 1._r_2
             temp0 = &
                   (((soil%sucs_vec(i,k)+ssnow%wtd(i)-zimm(i,k-1))/&
                      soil%sucs_vec(i,k)))**(1._r_2-1._r_2/soil%bch_vec(i,k))               
             voleq1 = -soil%sucs_vec(i,k)*(soil%ssat_vec(i,k)-soil%watr(i,k))/&
                       (1._r_2-1._r_2/soil%bch_vec(i,k))/&
                       (ssnow%wtd(i)-zimm(i,k-1))*(tempi-temp0)
             ssnow%wbeq(i,k) = (voleq1*(ssnow%wtd(i)-zimm(i,k-1)) +&
                               (soil%ssat_vec(i,k)-soil%watr(i,k))&
                               *(zimm(i,k)-ssnow%wtd(i)))/(zimm(i,k)-zimm(i,k-1))&
                                  + soil%watr(i,k)
             ssnow%wbeq(i,k) = ssnow%wbeq(i,k)*ice_correction(i,k)
          else

             tempi = (((soil%sucs_vec(i,k)+ssnow%wtd(i)-zimm(i,k))/&
                      soil%sucs_vec(i,k)))**(1._r_2-1._r_2/soil%bch_vec(i,k))
             temp0 = (((soil%sucs_vec(i,k)+ssnow%wtd(i)-zimm(i,k-1))/&
                     soil%sucs_vec(i,k)))**(1._r_2-1._r_2/soil%bch_vec(i,k))   
             ssnow%wbeq(i,k) = -soil%sucs_vec(i,k)*(soil%ssat_vec(i,k)-soil%watr(i,k))/&
                               (1._r_2-1._r_2/soil%bch_vec(i,k))/&
                               (zimm(i,k)-zimm(i,k-1))*(tempi-temp0)+soil%watr(i,k)
             ssnow%wbeq(i,k) = ssnow%wbeq(i,k)*ice_correction(i,k)

          end if
          
          ssnow%wbeq(i,k) = min(max(ssnow%wbeq(i,k),soil%watr(i,k)),soil%ssat_vec(i,k))
          
          ssnow%wbeq(i,k) = ssnow%wbeq(i,k)*ice_correction(i,k)

          wbrat = min(max((&
                  ssnow%wbeq(i,k) - soil%watr(i,k))/(soil%ssat_vec(i,k)-soil%watr(i,k)),&
                          0.001_r_2),1._r_2)

          ssnow%zq(i,k) = max(&
                            -soil%sucs_vec(i,k)*(wbrat**(-soil%bch_vec(i,k))),sucmin)

          if (gw_params%ssgw_ice_switch) then
             ssnow%zq(i,k) = max(&
                            -soil%sucs_vec(i,k)*(1._r_2+8._r_2*ssnow%wbice(i,k))*(wbrat**(-soil%bch_vec(i,k))),sucmin)
          end if
        
          
          
       end do  !mp
    end do  !ms
 
    do i=1,mp
    !Aquifer Equilibrium water content
       if (ssnow%wtd(i) .le. zimm(i,ms)) then      !fully saturated

          ssnow%GWwbeq(i) = soil%GWssat(i)
          ssnow%GWzq(i) = -soil%GWsucs(i)
          ssnow%GWzaq(i) = zimm(i,ms)+0.5*soil%GWdz(i)*1000._r_2

       !elseif ((ssnow%wtd(i) .gt. GWzimm(i)))   then     !fully unsaturated

       !   tempi = &
       !         (((soil%GWsucs(i)+ssnow%wtd(i)-GWzimm(i))/&
       !           soil%GWsucs(i)))**(1._r_2-1._r_2/soil%GWbch(i))
       !   temp0 = (((soil%GWsucs(i)+ssnow%wtd(i)-zimm(i,ms))/&
       !              soil%GWsucs(i)))**(1._r_2-1._r_2/soil%GWbch(i))   
       !   ssnow%GWwbeq(i) = -soil%GWsucs(i)*soil%GWssat(i)/&
       !                   (1._r_2-1._r_2/soil%GWbch(i))/&
       !                    (GWzimm(i)-zimm(i,ms))*(tempi-temp0) + soil%GWwatr(i)   

       !else           

       !   tempi  = 1._r_2
       !   temp0  = (((soil%GWsucs(i)+ssnow%wtd(i)-zimm(i,ms))/&
       !              soil%GWsucs(i)))**(1._r_2-1._r_2/soil%GWbch(i))               
       !   voleq1 = -soil%GWsucs(i)*(soil%GWssat(i)-soil%GWwatr(i))/&
       !             (1._r_2-1._r_2/soil%GWbch(i))/&
       !             (ssnow%wtd(i)-zimm(i,ms))*(tempi-temp0) + soil%GWwatr(i)
       !   ssnow%GWwbeq(i) = (voleq1*(ssnow%wtd(i)-zimm(i,ms)) + &
       !                     (soil%GWssat(i)-soil%GWwatr(i))*&
       !                  (GWzimm(i)-ssnow%wtd(i)))/(GWzimm(i)-zimm(i,ms)) + soil%GWwatr(i)
       elseif (ssnow%wtd(i) .gt. (zimm(i,ms)+0.5*soil%GWdz(i))*1000._r_2) then
          ssnow%GWzq(i) = -(ssnow%wtd(i) - (zimm(i,ms)+0.5*soil%GWdz(i))*1000._r_2)

          ssnow%GWzaq(i) = zimm(i,ms)+0.5*soil%GWdz(i)*1000._r_2
          ssnow%GWwbeq(i) = soil%GWssat(i)  !not used set to junk for now.

       else
          ssnow%GWzq(i) = -(ssnow%wtd(i) - (sum(soil%zse_vec(i,:),dim=1)))/2._r_2
          ssnow%GWzaq(i) = zimm(i,ms) + 0.5*(ssnow%wtd(i)-zimm(i,ms))
          ssnow%GWwbeq(i) = soil%GWssat(i)  !not used set to junk for now.
       end if

       !ssnow%GWwbeq(i) = min(max(ssnow%GWwbeq(i),soil%GWwatr(i)),soil%GWssat(i))

       !ssnow%GWzq(i) = -soil%GWsucs(i)*(max((ssnow%GWwbeq(i)-soil%GWwatr(i))/     &
       !             (soil%GWssat(i)-soil%GWwatr(i)),0.001_r_2))**(-soil%GWbch(i))
       !ssnow%GWzq(i) = max(sucmin, ssnow%GWzq(i))
       
    end do

END SUBROUTINE calc_equilibrium_water_content

SUBROUTINE calc_srf_wet_fraction(ssnow,soil,met,veg)
USE cable_common_module, ONLY : gw_params,cable_user
  IMPLICIT NONE
    TYPE(soil_snow_type), INTENT(INOUT)      :: ssnow  ! soil+snow variables
    TYPE(soil_parameter_type), INTENT(INOUT)    :: soil ! soil parameters
    TYPE(veg_parameter_type) , INTENT(IN   )  :: veg
    TYPE(met_type)           , INTENT(IN   )  :: met ! all met forcing

    !local variables
    REAL(r_2), DIMENSION(mp)           :: icef,satfrac_liqice,S
    REAL(r_2)                          :: fice,xx
    REAL(r_2),dimension(mp)            :: dzmm_one
    REAL(r_2)                          :: liqmass,icemass,totmass
    INTEGER                            :: i,j,k
    REAL(r_2), parameter               :: pi=3.1415926535898
    REAL(r_2)                          :: wb_unsat,wb_lin,funcval
    REAL(r_2)                          :: derv,slopeSTDmm,func_step
    REAL(r_2)                          :: wb_evap_threshold
    TYPE(issnow_type) :: Ctmp

    CALL point2constants( Ctmp )

    call saturated_fraction(ssnow,soil)

    IF (cable_user%or_evap) THEN

       ssnow%wetfac(:) = 1.0

    ELSEIF (cable_user%gw_model) THEN

       dzmm_one  = 1000._r_2 * soil%zse_vec(:,1)
   
       do i = 1,mp
          icemass  = ssnow%wbice(i,1) * dzmm_one(i) * Ctmp%density_ice/Ctmp%density_liq
          liqmass  = (ssnow%wb(i,1)-ssnow%wbice(i,1)) * dzmm_one(i)
          totmass  = max(liqmass+icemass,real(1e-2,r_2))
          icef(i)     = max(0._r_2,min(1._r_2, gw_params%IceBeta*icemass / totmass))
      end do
   
   
      !srf frozen fraction.  should be based on topography
      do i = 1,mp
         fice = (exp(-gw_params%IceAlpha*(1._r_2-icef(i)))-&
                 exp(-gw_params%IceAlpha))/&
                 (1._r_2-exp(-gw_params%IceAlpha))
         fice = min(1._r_2,max(0._r_2,fice))
   
         satfrac_liqice(i) = fice + (1._r_2-fice)*ssnow%satfrac(i)
   
         wb_unsat = ((ssnow%wb(i,1)-ssnow%wbice(i,1)) -&
                     ssnow%satfrac(i)*soil%ssat_vec(i,1))/(1.-ssnow%satfrac(i))
         wb_unsat = min(soil%ssat_vec(i,1),max(0.,wb_unsat))
   
         wb_evap_threshold = min( max( &
                             gw_params%SoilEvapAlpha*soil%sfc_vec(i,1), &
                             soil%swilt_vec(i,1) ), soil%ssat_vec(i,1) )
   
         !Sakguchi and Zeng 2009
         if (wb_unsat .ge. wb_evap_threshold) then
            xx = 1.
         else
            xx = 0.25 * (1._r_2 - cos(pi*wb_unsat/(wb_evap_threshold)))**2.0
         end if
   
         ssnow%wetfac(i) = max(0.0,min(1.0,satfrac_liqice(i) +&
                                        (1. - satfrac_liqice(i))*xx ) )

      end do

   ELSE  !Default formulation

       ssnow%wetfac = MAX( 1.e-6, MIN( 1.0,&
            ( REAL (ssnow%wb(:,1) ) - soil%swilt/ 2.0 )                  &
            / ( soil%sfc - soil%swilt/2.0 ) ) )
   
       DO i=1,mp
   
          IF( ssnow%wbice(i,1) > 0. )&
               ssnow%wetfac(i) = ssnow%wetfac(i) * &
                                real(MAX( 0.5_r_2, 1._r_2 - MIN( 0.2_r_2, &
                                 ( ssnow%wbice(i,1) / ssnow%wb(i,1) )**2 ) ) )
   
          IF( ssnow%snowd(i) > 0.1) ssnow%wetfac(i) = 0.9
   
          IF ( veg%iveg(i) == 16 .and. met%tk(i) >= Ctmp%tfrz + 5. )   &
               ssnow%wetfac(i) = 1.0 ! lakes: hard-wired number to be removed
   
          IF( veg%iveg(i) == 16 .and. met%tk(i) < Ctmp%tfrz + 5. )   &
               ssnow%wetfac(i) = 0.7 ! lakes: hard-wired number to be removed
   
       ENDDO
       ! owetfac introduced to reduce sharp changes in dry regions,
       ! especially in offline runs in which there may be discrepancies b/n
       ! timing of precip and temperature change (EAK apr2009)
       ssnow%wetfac = 0.5*(ssnow%wetfac + ssnow%owetfac)

   ENDIF  !or_evap, gw_model, or default wetfac parameterization

END SUBROUTINE calc_srf_wet_fraction

SUBROUTINE calc_soil_hydraulic_props(ssnow,soil,veg)
   USE cable_common_module
   TYPE(soil_parameter_type), INTENT(INOUT)     :: soil 
   TYPE(soil_snow_type)     , INTENT(INOUT)  :: ssnow
   TYPE(veg_parameter_type) , INTENT(INOUT)     :: veg

   INTEGER :: i,k,kk

   REAL(r_2), DIMENSION(mp) :: s1, &  !temporary variables for calculating hydraulic properties
                               s2, &
                               s_mid, &
                               liq_ratio, &
                               Dliq_ratio_Dz

   REAL(r_2), DIMENSION(mp,0:ms) :: zimm  !depths at interface between layers
   REAL(r_2) ,pointer, dimension(:,:) :: wb_temp 
   REAL(r_2) :: rel1_psi,rel2_psi,hk1,hk2

    !soil matric potential, hydraulic conductivity, and derivatives of each with respect to water (calculated using total (not liquid))

    do k=1,ms
       do i=1,mp
          ssnow%icefrac(i,k) = ssnow%wbice(i,k)/(max(ssnow%wb(i,k),0.01_r_2))
          ssnow%fracice(i,k) = (exp(-gw_params%IceAlpha*(1._r_2-ssnow%icefrac(i,k)))&
                               -exp(-gw_params%IceAlpha))/(1._r_2-exp(-gw_params%IceAlpha))
       end do
    end do

    ssnow%fracice(:,:) = max( min( ssnow%fracice, 1._r_2), 0._r_2)

    if (gw_params%ssgw_ice_switch) then
       wb_temp => ssnow%wbliq
    else
       wb_temp => ssnow%wb
    end if

    do k=1,ms-1
       kk=k+1
       do i=1,mp

          if (.not.gw_params%ssgw_ice_switch) then
             s1(i) = 0.5_r_2*(max(wb_temp(i,k)-soil%watr(i,k),0.) + &
                              max(wb_temp(i,kk)-soil%watr(i,kk),0.)) / &
                            (0.5_r_2*((soil%ssat_vec(i,k)-soil%watr(i,k)) + &
                            (soil%ssat_vec(i,kk)-soil%watr(i,kk))))

             s1(i) = min(max(s1(i),0.01_r_2),1._r_2)
             s2(i) = soil%hyds_vec(i,k)*s1(i)**(2._r_2*soil%bch_vec(i,k)+2._r_2)

             ssnow%hk(i,k)    =  s1(i)*s2(i)
             ssnow%dhkdw(i,k) = (2._r_2*soil%bch_vec(i,k)+3._r_2)*s2(i)*&
                               0.5_r_2/(soil%ssat_vec(i,k)-soil%watr(i,k))
             ssnow%hk(i,k)    = ssnow%hk(i,k)*&
                                 (1.0 - 0.5_r_2*(ssnow%fracice(i,k)+ssnow%fracice(i,kk)))
             ssnow%dhkdw(i,k) = ssnow%dhkdw(i,k)*&
                                  (1.0 - 0.5_r_2*(ssnow%fracice(i,k)+ssnow%fracice(i,kk)))

          else
              rel1_psi = max(0.5_r_2*(ssnow%smp(i,k)+ssnow%GWsmp(i))/(-soil%sucs_vec(i,k)),1._r_2)
              ssnow%hk(i,k) = soil%hyds_vec(i,k)* (rel1_psi**(-2._r_2 - 3._r_2/soil%bch_vec(i,k)) )
              ssnow%dhkdw(i,k) = -soil%hyds_vec(i,k)* (rel1_psi**(-3._r_2 - 3._r_2/soil%bch_vec(i,k)) )*&
                                     (-2._r_2 - 3._r_2/soil%bch_vec(i,k))/soil%sucs_vec(i,k)
          end if

       end do
    end do

    k = ms 
       do i=1,mp

          if (.not. gw_params%ssgw_ice_switch) then

              s1(i) = 0.5_r_2*(max(wb_temp(i,k)  -soil%watr(i,k),0.) + &
                               max(wb_temp(i,k+1)-soil%GWwatr(i),0.)) / &
                      (0.5_r_2*(soil%ssat_vec(i,k)-soil%watr(i,k) +&
                                soil%GWssat(i)-soil%GWwatr(i)))
              s1(i) = min(max(s1(i),0.01_r_2),1._r_2)
              s2(i) = soil%hyds_vec(i,k)*s1(i)**(2._r_2*soil%bch_vec(i,k)+2._r_2)

              ssnow%hk(i,k)    = s1(i)*s2(i)
              ssnow%dhkdw(i,k) = (2._r_2*soil%bch_vec(i,k)+3._r_2)*&
                                 s2(i)*0.5_r_2/(soil%ssat_vec(i,k)-soil%watr(i,k))

              ssnow%hk(i,k)    =  (1.-ssnow%fracice(i,k))*ssnow%hk(i,k)
              ssnow%dhkdw(i,k) =  (1.-ssnow%fracice(i,k))*ssnow%dhkdw(i,k)

            else
              rel1_psi = max(0.5_r_2*(ssnow%smp(i,k)+ssnow%GWsmp(i))/(-soil%sucs_vec(i,k)),1._r_2)
              ssnow%hk(i,k) = soil%hyds_vec(i,k)* (rel1_psi**(-2._r_2 - 3._r_2/soil%bch_vec(i,k)) )
              ssnow%dhkdw(i,k) = -soil%hyds_vec(i,k)* (rel1_psi**(-3._r_2 - 3._r_2/soil%bch_vec(i,k)) )*&
                                 (-2._r_2 - 3._r_2/soil%bch_vec(i,k))/soil%sucs_vec(i,k)
            end if

       end do
 
    do k=1,ms 
       do i=1,mp
         if (.not.gw_params%ssgw_ice_switch) then
          s_mid(i) = (ssnow%wb(i,k)-soil%watr(i,k))/&  !+dri*ssnow%wbice(:,k)
              (soil%ssat_vec(i,k)-soil%watr(i,k))

          s_mid(i) = min(max(s_mid(i),0.001_r_2),1._r_2)

          ssnow%smp(i,k) = -soil%sucs_vec(i,k)*s_mid(i)**(-soil%bch_vec(i,k))

          ssnow%smp(i,k) = max(min(ssnow%smp(i,k),-soil%sucs_vec(i,k)),sucmin)

          ssnow%dsmpdw(i,k) = -soil%bch_vec(i,k)*ssnow%smp(i,k)/&
                    (max(s_mid(i)*(soil%ssat_vec(i,k)-soil%watr(i,k)),0.001_r_2))       

         else
          s_mid(i) = (wb_temp(i,k)-soil%watr(i,k))/&  !+dri*ssnow%wbice(:,k)
              (soil%ssat_vec(i,k)-soil%watr(i,k))

          s_mid(i) = min(max(s_mid(i),0.001_r_2),1._r_2)

          ssnow%smp(i,k) = -soil%sucs_vec(i,k)*s_mid(i)**(-soil%bch_vec(i,k))*&
                            (1._r_2 + 8._r_2*ssnow%wbice(i,k))**2.0

          ssnow%smp(i,k) = max(min(ssnow%smp(i,k),-soil%sucs_vec(i,k)),sucmin)

          ssnow%dsmpdw(i,k) = -soil%bch_vec(i,k)*ssnow%smp(i,k)/&
                    (max(s_mid(i)*(soil%ssat_vec(i,k)-soil%watr(i,k)),0.001_r_2)) *&
                         (1._r_2+8._r_2*ssnow%wbice(i,k))**2._r_2

         end if
       end do   
    end do

    if (gw_params%ssgw_ice_switch) then
       liq_ratio(:) = ssnow%wbliq(:,ms)/(ssnow%wbliq(:,ms) +  &
                        (C%density_liq/C%density_ice)*ssnow%wbice(:,ms))
    else
       liq_ratio(:) = 1._r_2
    endif

    do i=1,mp
       !Aquifer properties
       s_mid(i) = (ssnow%GWwb(i)*liq_ratio(i)-soil%GWwatr(i))/&
                    (soil%GWssat(i)-soil%GWwatr(i))
       s_mid(i) = min(max(s_mid(i),0.001_r_2),1._r_2)
       s2(i)    = soil%GWhyds(i)*s_mid(i)**(2._r_2*soil%GWbch(i)+2._r_2)

       ssnow%GWhk(i)     =s_mid(i)*s2(i)

       ssnow%GWdhkdw(i)  =  (2._r_2*soil%GWbch(i)+3._r_2)*&
                           s2(i)*0.5_r_2/(soil%GWssat(i)-soil%GWwatr(i))

       if (.not.gw_params%ssgw_ice_switch) then
          ssnow%GWhk(i)    = (1.-ssnow%fracice(i,ms)) * ssnow%GWhk(i)
          ssnow%GWdhkdw(i) = (1.-ssnow%fracice(i,ms)) * ssnow%GWdhkdw(i)

          s_mid(i) = (ssnow%GWwb(i)-soil%GWwatr(i))/(soil%GWssat(i)-soil%GWwatr(i))
          s_mid(i) = min(max(s_mid(i),0.001_r_2),1._r_2)
   
          ssnow%GWsmp(i)    = -soil%GWsucs(i)*s_mid(i)**(-soil%GWbch(i))
          ssnow%GWsmp(i)    = max(min(ssnow%GWsmp(i),-soil%GWsucs(i)),sucmin)
          ssnow%GWdsmpdw(i) = -soil%GWbch(i)*ssnow%GWsmp(i)/&
                               (s_mid(i)*(soil%GWssat(i)-soil%GWwatr(i)))

       else

          ssnow%GWsmp(i)    = -soil%GWsucs(i)*s_mid(i)**(-soil%GWbch(i))*&
                               (1._r_2+ 8._r_2*ssnow%GWwb(i)*(1._r_2-liq_ratio(i)))**2.0
          ssnow%GWsmp(i)    = max(min(ssnow%GWsmp(i),-soil%GWsucs(i)),sucmin)
          ssnow%GWdsmpdw(i) = -soil%GWbch(i)*ssnow%GWsmp(i)/& 
                               (s_mid(i)*(soil%GWssat(i)-soil%GWwatr(i))) * &
                               (1._r_2+ 8._r_2*ssnow%GWwb(i)*(1._r_2-liq_ratio(i)))**2.0
       end if
    end do

END SUBROUTINE calc_soil_hydraulic_props

  SUBROUTINE aquifer_recharge(dt,ssnow,soil,veg,zmm,dzmm)
  USE cable_common_module

  IMPLICIT NONE
    real, intent(in) :: dt 
    TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
    TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
    TYPE (veg_parameter_type), INTENT(INOUT)     :: veg
    REAL(r_2), dimension(:,:), intent(in)       :: zmm
    REAL(r_2), dimension(:,:), intent(in)     :: dzmm

    integer :: i    

    !Doing the recharge outside of the soln of Richards Equation makes it easier to track total recharge amount.
    !Add to ssnow at some point 
    do i=1,mp
       if ((ssnow%wtd(i) .le. sum(dzmm(i,:),dim=1)) .or. &
           (veg%iveg(i) .ge. 16) .or. &
           (soil%isoilm(i) .eq. 9))  then

          ssnow%Qrecharge(i) = 0._r_2
       else
          ssnow%Qrecharge(i) = -0.5*(ssnow%hk(i,ms)+ &
                                soil%GWhyds(i)*(1.0-ssnow%fracice(i,ms) ))*&
                               ((0._r_2-ssnow%smp(i,ms)) -&
                                (ssnow%wtd(i)-zmm(i,ms))) / &
                                (ssnow%wtd(i) - zmm(i,ms))
       end if
    end do


  END SUBROUTINE aquifer_recharge

  SUBROUTINE subsurface_drainage(ssnow,soil,veg,dzmm)
  USE cable_common_module

  IMPLICIT NONE
  
    TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
    TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
    TYPE (veg_parameter_type), INTENT(INOUT)     :: veg
    REAL(r_2), dimension(:,:), intent(in)       :: dzmm
    REAL(r_2), dimension(mp)                  :: sm_tot
    INTEGER, dimension(mp)                    :: k_drain
    integer :: i,k

    real(r_2), dimension(17) :: Efold_mod

    Efold_mod(:) = 1.0
    !Efold_mod(1:4) = (/0.2,0.2,0.2,0.2/)
    !Efold_mod(9) = 0.25
    do i=1,mp

       !Note: future revision will have interaction with river here. nned to
       !work on router and add river type cells
       ssnow%qhz(i)  = min(max(soil%slope(i),0.00001),0.1)*&
                       gw_params%MaxHorzDrainRate* &
                        exp(-ssnow%wtd(i)/(1000._r_2*&
                       (gw_params%EfoldHorzDrainRate*Efold_mod(veg%iveg(i)))))

       if (gw_params%subsurface_sat_drainage) then
          !drain from sat layers
          k_drain(i) = ms+1
          do k=ms,2,-1
             if (ssnow%wtd(i) .le. sum(dzmm(i,1:k),dim=1)) then
                k_drain(i) = k + 1
             end if
          end do
          k_drain(i) = max(k_drain(i),3)
       else
          k_drain(i) = 2
       end if

   end do

   do i=1,mp
       ssnow%qhlev(i,:) = 0._r_2
       sm_tot(i) = 0._r_2
       ssnow%qhlev(i,:) = 0._r_2

       if (gw_params%subsurface_sat_drainage) then
          sm_tot(i) = max((ssnow%GWwb(i) - soil%watr(i,ms))*&
                          (1._r_2-ssnow%fracice(i,ms)), 0.)

          do k=k_drain(i),ms
             sm_tot(i) = sm_tot(i) +max(ssnow%wbliq(i,k)-soil%watr(i,k),0._r_2)
          end do

          if (sm_tot(i) .ge. 1.0e-12) then
              do k=k_drain(i),ms
                 ssnow%qhlev(i,k) = ssnow%qhz(i)*max(&
                                   ssnow%wbliq(i,k)-soil%watr(i,k),0._r_2)/sm_tot(i)
              end do
              ssnow%qhlev(i,ms+1) = max((ssnow%GWwb(i) - soil%watr(i,ms))*&
                                    (1._r_2-ssnow%fracice(i,ms)), 0.)*ssnow%qhz(i)/sm_tot(i)
          endif

       else  !second option
          if (k_drain(i) .le. ms) then
             sm_tot(i) = 0.
             do k=k_drain(i),ms
                sm_tot(i) = sm_tot(i) + max(ssnow%wbliq(i,k)-soil%watr(i,k),0._r_2)
             end do

             if (sm_tot(i) .ge. 1.0e-12) then
                 do k=k_drain(i),ms
                    ssnow%qhlev(i,k) = ssnow%qhz(i)*max(&
                                        ssnow%wbliq(i,k)-soil%watr(i,k),0._r_2)/sm_tot(i)
                 end do
             endif

          else

             ssnow%qhlev(i,ms+1) = ssnow%qhz(i)*(1._r_2-ssnow%fracice(i,ms))

          end if

       end if
       !incase every layer is frozen very dry
       ssnow%qhz(i) = sum(ssnow%qhlev(i,:),dim=1)

       !Keep "lakes" saturated forcing qhz = 0.  runoff only from lakes
       !overflowing
       if (soil%isoilm(i) .eq. 9 .or. veg%iveg(i) .ge. 16) then
          ssnow%qhz(i) = 0._r_2
          ssnow%qhlev(i,:) = 0._r_2
       end if

    end do  


  END SUBROUTINE subsurface_drainage


  SUBROUTINE saturated_fraction(ssnow,soil)
    TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
    TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters

    REAL(r_2), DIMENSION(mp) :: S
    REAL(r_2) :: slopeSTDmm
    INTEGER :: i,k

     S(:) = 0._r_2
     do k=1,ms
       S(:) = S(:) + max(0.01,min(1.0, &
              (ssnow%wb(:,k)-ssnow%wbice(:,k)-soil%watr(:,k))/&
               max(0.001,soil%ssat_vec(:,k)-soil%watr(:,k)) ) )*soil%zse_vec(:,k)
     end do
     S(:) = S(:)/sum(soil%zse_vec(:,1:ms),dim=2)
     !srf frozen fraction.  should be based on topography
      do i = 1,mp
         !Saturated fraction
          if (gw_params%MaxSatFraction .gt. 1e-7) then 
             slopeSTDmm = sqrt(min(max(&
                           gw_params%MaxSatFraction*soil%slope_std(i),&
                           1e-5),10000._r_2)) ! ensure some variability
             ssnow%satfrac(i)    = max(0._r_2,min(0.99_r_2,&
                 !note UM wants std03, and erf is not included then
                                   1._r_2 - my_erf( slopeSTDmm / sqrt(2.0* S(i)) ) ) )  
          else
             ssnow%satfrac(i) = 0._r_2
          end if
      end do


  END SUBROUTINE saturated_fraction

  SUBROUTINE pore_space_relative_humidity(ssnow,soil,veg)
    TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
    TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
    TYPE(veg_parameter_type), INTENT(INOUT)      :: veg

    REAL(r_2), DIMENSION(mp) :: unsat_wb,unsat_smp
    INTEGER :: i

    do i=1,mp
       if (veg%iveg(i) .lt. 16 .and. soil%isoilm(i) .ne. 9 .and. &
           ssnow%snowd(i) .le. 1e-8 ) then

          unsat_wb(i) =  (ssnow%wb(i,1) - soil%ssat_vec(i,1)*&
                      min(0.99,ssnow%satfrac(i)))/(1.0 - min(0.99,ssnow%satfrac(i)))  

          unsat_wb(i) = max(soil%watr(i,1)+1e-6, min(soil%ssat_vec(i,1), unsat_wb(i) ) )

          unsat_smp(i) = sign(soil%sucs_vec(i,1),-1.0) * &
                         ( (unsat_wb(i)-soil%watr(i,1))/(soil%ssat_vec(i,1)-&
                         soil%watr(i,1)) ) ** (-soil%bch_vec(i,1))

          ssnow%rh_srf(i) = max(0.,min(1., &
                         exp(9.81*unsat_smp(i)/1000.0/ssnow%tss(i)/461.4) ) )
         
       else

          ssnow%rh_srf(i) = 1.0

       end if
    end do  


  END SUBROUTINE pore_space_relative_humidity

  SUBROUTINE sli_hydrology(dels,ssnow,soil,veg,canopy)
    REAL, INTENT(IN)                         :: dels ! integration time step (s)
    TYPE(soil_snow_type), INTENT(INOUT)      :: ssnow  ! soil+snow variables
    TYPE(soil_parameter_type), INTENT(INOUT)    :: soil ! soil parameters
    TYPE(veg_parameter_type) , INTENT(INOUT)    :: veg  ! veg parameters
    TYPE (canopy_type), INTENT(INOUT)           :: canopy

    LOGICAL, SAVE :: sli_call = .true.

    REAL(r_2), DIMENSION(mp,ms) :: dzmm
    REAL(r_2), DIMENSION(mp,ms) :: zmm
    REAL(r_2), DIMENSION(mp) :: zaq
    integer, dimension(mp) :: single_level
    integer :: k

    single_level = -1


   call iterative_wtd (ssnow, soil, veg, cable_user%test_new_gw,single_level)

   CALL calc_soil_hydraulic_props(ssnow,soil,veg)

   call  ovrlndflx (dels, ssnow, soil, veg,canopy,sli_call )

   dzmm = soil%zse_vec(:,:)*1000._r_2

   CALL subsurface_drainage(ssnow,soil,veg,dzmm)

   zmm(:,1) = 1000._r_2*soil%zse_vec(:,1)
   do k=2,ms
      zmm(:,k) = 1000._r_2*(sum(soil%zse_vec(:,1:k),dim=2))
   end do

   call aquifer_recharge(dels,ssnow,soil,veg,zmm,dzmm)




  END SUBROUTINE sli_hydrology


  SUBROUTINE set_unsed_gw_vars(ssnow,soil,canopy)
    TYPE(soil_snow_type), INTENT(INOUT)      :: ssnow  ! soil+snow variables
    TYPE(soil_parameter_type), INTENT(INOUT)    :: soil ! soil parameters
    TYPE (canopy_type), INTENT(INOUT)           :: canopy

       ssnow%qhlev = 0.
       ssnow%Qrecharge = 0.
       ssnow%fwtop = 0.
       ssnow%wtd = 0.
       ssnow%satfrac = 1.0
       ssnow%qhz = 0.
       ssnow%wbliq = ssnow%wb - ssnow%wbice
       canopy%sublayer_dz = 0.0
       ssnow%rtevap_sat = 0.0
       ssnow%rtevap_unsat = 0.0

       ssnow%GWwb = 0.9*soil%ssat


  END SUBROUTINE set_unsed_gw_vars

  real(r_2) function my_erf(x)

  implicit none

  real(r_2), intent(in) :: x 
  real(r_2)             :: tmp_val, tmp


   tmp = 1.0 / ( 1.0 + 0.5 * abs(x) )

   tmp_val =  tmp * exp(-abs(x) * abs(x) - 1.26551223 + tmp *     &
             ( 1.00002368 + tmp * ( 0.37409196 + tmp *          &
         ( 0.09678418 + tmp * (-0.18628806 + tmp *              &
                     ( 0.27886807 + tmp * (-1.13520398 + tmp *          &
         ( 1.48851587 + tmp * (-0.82215223 + tmp * 0.17087277 )))))))))

  if ( x.lt.0.0 ) tmp_val = 2.0 - tmp_val

  my_erf = 1.0 - tmp_val

  end function my_erf

SUBROUTINE subgrid_sm_transfer(dels,ssnow,soil,veg)
  USE cable_IO_vars_module , ONLY : landpt
  
  implicit none
  REAL, INTENT(IN)                              :: dels
  TYPE (soil_snow_type), INTENT(INOUT)      :: ssnow ! soil and snow variables
  TYPE (soil_parameter_type), INTENT(INOUT)    :: soil  ! soil parameters
  TYPE (veg_parameter_type), INTENT(INOUT)     :: veg
  
  !local variables
  integer :: i,ii,k,kk,ib,ie,j,jj,klev
  real(r_2), dimension(mp)     :: qsrf_store_n,qsrf_flow_n, q_tot, wb_avg
  real(r_2), dimension(mp,ms+1) :: q_lev
  
  real(r_2) :: def, theta, ani,f, slope  !ani = anisotopic factor (2e3 for chen kumar 2001)
  real(r_2) :: q_tmp,space_avail,water_avail

  logical :: verbose_debug

  verbose_debug = .false.
  ani = 2.0e3
  f = 1. / sum(soil%zse)
 
  ssnow%qhlev(:,:) = 0.  !horz flux in unsat zone
  q_tot(:) = 0.0         !horz flux in sat zone

  do i=1,mland
  
    ib = landpt(i)%cstart
    ie = landpt(i)%cend

    do ii=ib,ie

       do jj=ii+1,ie

        q_tmp  =  0.5*(soil%hyds_vec(ii,ms)+soil%hyds_vec(jj,ms))*&
                                   ani * dels *  &
                                   min(1.0-ssnow%fracice(ii,ms),1.0-ssnow%fracice(jj,ms))*&
                                   exp(-0.0005*gw_params%EfoldHorzDrainRate*(ssnow%wtd(jj)+ssnow%wtd(ii))) *&
                                   ((ssnow%wtd(jj)-ssnow%wtd(ii))/soil%flow_dist(ii,jj-ib) + &
                                   soil%flow_elev(ii,jj-ib)/soil%flow_dist(ii,jj-ib) )*&
                                   soil%flow_frac(ii,jj-ib)

        q_tot(ii) = q_tot(ii) + q_tmp

        q_tot(jj) = q_tot(jj) - q_tmp

        !!simple predict correct?
        !simple method for explicit horz fluxes, could it be stable?
        !do klev=1,ms

        !   q_tmp =   ani * 1._r_2/(sqrt(1._r_2 + &
        !             (soil%flow_elev(ii,jj-ib)/soil%flow_dist(ii,jj-ib))**2.0)*&
        !              0.5*(ssnow%hk(ii,klev) + ssnow%hk(jj,klev)) *&
        !             -(ssnow%smp(jj,klev)-ssnow%smp(ii,klev))/soil%flow_dist(ii,jj-ib)/1000._r_2

        !   ssnow%qhlev(ii,klev) = ssnow%qhlev(ii,klev) - q_tmp
        !   ssnow%qhlev(jj,klev) = ssnow%qhlev(jj,klev) + q_tmp
        !end do
       end do
    end do

  end do

  ssnow%Qconv(:) = q_tot(:)


  do i=1,mp


     if (q_tot(i) .gt. 0._r_2) then

        if (ssnow%GWwb(i) .lt. soil%GWssat(i)) then 

           space_avail = (soil%GWssat(i) - ssnow%GWwb(i)) * soil%GWdz(i) * 1000._r_2

           if (q_tot(i) .le. space_avail) then
              ssnow%qhlev(i,ms+1) = ssnow%qhlev(i,ms+1) - q_tot(i)/dels
              ssnow%GWwb(i) = ssnow%GWwb(i) + q_tot(i)/(1000._r_2 * soil%GWdz(i))
              q_tot(i) = 0._r_2
           else
              ssnow%qhlev(i,ms+1) = ssnow%qhlev(i,ms+1) -  space_avail/dels
              q_tot(i) = q_tot(i) - space_avail
              ssnow%GWwb(i) = soil%GWssat(i)
           end if
        end if

        do k=ms,1,-1

           if (q_tot(i) .gt. 0._r_2 .and. ((soil%ssat_vec(i,k)-ssnow%wbice(i,k)) .gt. ssnow%wbliq(i,k)) ) then

              space_avail = ((soil%ssat_vec(i,k)-ssnow%wbice(i,k))  - &
                             ssnow%wbliq(i,k)) * soil%zse(k) * 1000._r_2

              if (q_tot(i) .le. space_avail) then
                 ssnow%qhlev(i,k) = ssnow%qhlev(i,k) - q_tot(i)/dels
                 ssnow%wbliq(i,k) = ssnow%wbliq(i,k) + q_tot(i)/(1000._r_2 * soil%zse(k))
                 q_tot(i) = 0._r_2
              else
                 ssnow%qhlev(i,k) = ssnow%qhlev(i,k) - space_avail/dels
                 q_tot(i) = q_tot(i) - space_avail
                 ssnow%wbliq(i,k) = soil%ssat_vec(i,k) - ssnow%wbice(i,k)
              end if
           end if

        end do

        !if any left add to srf runoff
        ssnow%rnof1(i) = ssnow%rnof1(i) + q_tot(i)/dels
        q_tot(i) = 0._r_2


     else

     !find wtd layer
   
        klev = ms+1
        do k=ms,1,-1
   
           if (sum(soil%ssat_vec(i,k:ms) - (ssnow%wbliq(i,k:ms)+ssnow%wbice(i,k:ms)),dim=1) .le. 0.01 ) then
              klev = k
            end if
        end do
   
        if (klev .eq. ms+1 .and. abs(q_tot(i)) .gt. 0._r_2)  then  !remove from aq
   
           water_avail = (ssnow%GWwb(i)-soil%GWwatr(i))*soil%GWdz(i)*1000._r_2
   
           if (abs(q_tot(i)) .le. water_avail) then
              ssnow%GWwb(i) = ssnow%GWwb(i) + q_tot(i)/soil%GWdz(i)/1000._r_2
              ssnow%qhlev(i,ms+1) = ssnow%qhlev(i,ms+1) - q_tot(i)/dels
              q_tot(i) = 0._r_2
           else
              ssnow%qhlev(i,ms+1) = ssnow%qhlev(i,ms+1) + (q_tot(i) + water_avail)/dels
              q_tot(i) = q_tot(i) + water_avail
              ssnow%GWwb(i) = soil%GWwatr(i)
           end if
   
        end if
   
        do k=klev,ms
   
           if (abs(q_tot(i)) .gt. 0._r_2) then
              water_avail = (ssnow%wbliq(i,k)-soil%watr(i,k))*soil%zse(k)*1000._r_2
   
              if (abs(q_tot(i)) .le. water_avail) then
                 ssnow%wbliq(i,k) = ssnow%wbliq(i,k) + q_tot(i)/soil%zse(k)/1000._r_2
                 ssnow%qhlev(i,k) = ssnow%qhlev(i,k) - q_tot(i)/dels
                 q_tot(i) = 0._r_2
              else
                 ssnow%qhlev(i,k) = ssnow%qhlev(i,k) + water_avail/dels
                 q_tot(i) = q_tot(i) + water_avail
                 ssnow%wbliq(i,k) = soil%watr(i,k)
              end if
   
           end if
        end do

     end if  !convergence or divergence

   end do           
  
  !ensure conserve water 
  do i=1,mland         
    ib = landpt(i)%cstart
    ie = landpt(i)%cend

     do ii=ib,ie
  
        if (abs(q_tot(ii)) .gt. 0._r_2) then
           if (ii .lt. ie) then  !remove from next cell

              q_tot(ii+1) = q_tot(ii+1) + q_tot(ii)

           else
              ssnow%qhz(ii) = q_tot(ii)/dels
           end if

           q_tot(ii) = 0._r_2

        end if   
     end do
   end do

  
END SUBROUTINE  subgrid_sm_transfer

! calculates temperatures of the soil
! tgg - new soil/snow temperature
! ga - heat flux from the atmosphere (ground heat flux)
! ccnsw - soil thermal conductivity, including water/ice
SUBROUTINE GWstempv(dels, canopy, ssnow, soil)
   REAL, INTENT(IN) :: dels ! integration time step (s)

   TYPE(canopy_type),    INTENT(INOUT) :: canopy
   TYPE(soil_snow_type), INTENT(INOUT) :: ssnow

   TYPE(soil_parameter_type), INTENT(INOUT) :: soil

   REAL, DIMENSION(mp) ::                                                      &
      coefa, coefb,  & !
      sgamm            !

   REAL(r_2), DIMENSION(mp) ::                                                 &
      dtg,     & !
      ew,      & !
      xx,      & !
      wblfsp,css_adj     !

   REAL(r_2), DIMENSION(mp,ms+1) ::                                              &
      ccnsw  ! soil thermal conductivity (incl water/ice)

   REAL(r_2), DIMENSION(mp, -2:ms+1) ::                                          &
      at, bt, ct, rhs !

   REAL(r_2), DIMENSION(mp,-2:ms+2) :: coeff

   REAL(r_2), DIMENSION(mp,ms+4)    :: tmp_mat ! temp. matrix for tggsn & tgg

   INTEGER :: j,k
   REAL :: snow_ccnsw, exp_arg
   LOGICAL :: direct2min = .FALSE.

   CALL point2constants( C )

   at = 0.0
   bt = 1.0
   ct = 0.0
   coeff = 0.0
   snow_ccnsw = 2.0

   DO k = 1, ms

      DO j = 1, mp

         IF( soil%isoilm(j) == 9 ) THEN
            ! permanent ice: fix hard-wired number in next version
            ccnsw(j,k) = snow_ccnsw
         ELSE
            ew(j) = ssnow%wbliq(j,k)
            exp_arg = min(30., ( ew(j) * LOG( 60.0 ) ) + ( ssnow%wbice(j,k)            &
                       * LOG( 250.0 ) ))


            ccnsw(j,k) = MIN( soil%cnsd_vec(j,k) * EXP( exp_arg ), 1.5_r_2 )      &
                         * MAX( 1.0_r_2, SQRT( MIN( 2.0_r_2, 0.5 *          &
                         soil%ssat_vec(j,k) /                                     &
                         MIN( ew(j), 0.5_r_2 * soil%ssat_vec(j,k) ) ) ) )


         ENDIF

      END DO

   END DO

   k=ms+1
      DO j = 1, mp

         IF( soil%isoilm(j) == 9 ) THEN
            ! permanent ice: fix hard-wired number in next version
            ccnsw(j,k) = 2.0
         ELSE
            exp_arg = min(30.0, ( ssnow%GWwb(j) * LOG( 60.0 ) ))


               ccnsw(j,k) = MIN( 3.5  * EXP( min(exp_arg,30.0) ), 1.5_r_2 )      &
                            * MAX( 1.0_r_2, SQRT( MIN( 2.0_r_2, 0.5 *          &
                            soil%GWssat(j) /                                     &
                            MIN( ssnow%GWwb(j) , 0.5_r_2 * soil%GWssat(j) ) ) ) )


         ENDIF

      END DO


   xx = 0.

   WHERE(ssnow%isflag == 0)
      xx = MAX( 0., ssnow%snowd / ssnow%ssdnn )
      ccnsw(:,1) = ( ccnsw(:,1) - 0.2 ) * ( soil%zse(1) / ( soil%zse(1) + xx ) &
                   ) + 0.2
   END WHERE

   DO k = 3, ms
      WHERE (ssnow%isflag == 0)
         coeff(:,k) = 2.0 / ( soil%zse_vec(:,k-1) / ccnsw(:,k-1) + soil%zse_vec(:,k) /     &
                      ccnsw(:,k) )
      END WHERE
   END DO
   k=ms+1
      WHERE (ssnow%isflag == 0)
         coeff(:,k) = 2.0 / ( soil%zse_vec(:,k-1) / ccnsw(:,k-1) + soil%GWdz(:) /     &
                      ccnsw(:,k) )
      END WHERE

   k = 1
   WHERE( ssnow%isflag == 0 )
      coeff(:,2) = 2.0 / ( ( soil%zse_vec(:,1) + xx ) / ccnsw(:,1) + soil%zse_vec(:,2) /   &
                   ccnsw(:,2) )
      coefa = 0.0
      coefb = REAL( coeff(:,2) )

      ssnow%gammzz(:,k) = MAX( ( 1.0 - soil%ssat_vec(:,k) ) * soil%css_vec(:,k) * soil%rhosoil_vec(:,k)   &
                          + ( ssnow%wbliq(:,k) * cswat * C%density_liq +            &
                          ssnow%wbice(:,k) * csice * C%density_ice ), &
                           soil%css_vec(:,k) * soil%rhosoil_vec(:,k) )     &
                          * soil%zse_vec(:,k)

      ssnow%gammzz(:,k) = ssnow%gammzz(:,k) + cgsnow * ssnow%snowd

      dtg = dels / ssnow%gammzz(:,k)

      at(:,k) = - dtg * coeff(:,k)
      ct(:,k) = - dtg * coeff(:,k+1) ! c3(ms)=0 & not really used
      bt(:,k) = 1.0 - at(:,k) - ct(:,k)

   END WHERE

   DO k = 2, ms

      WHERE( ssnow%isflag == 0 )

         ssnow%gammzz(:,k) = MAX( ( 1.0 - soil%ssat_vec(:,k) ) * soil%css_vec(:,k) * soil%rhosoil_vec(:,k)   &
                          + ( ssnow%wbliq(:,k) * cswat * C%density_liq +            &
                          ssnow%wbice(:,k) * csice * C%density_ice ), &
                           soil%css_vec(:,k) * soil%rhosoil_vec(:,k) )     &
                          * soil%zse_vec(:,k)

         dtg = dels / ssnow%gammzz(:,k)
         at(:,k) = - dtg * coeff(:,k)
         ct(:,k) = - dtg * coeff(:,k+1) ! c3(ms)=0 & not really used
         bt(:,k) = 1.0 - at(:,k) - ct(:,k)

      END WHERE

   END DO

   k=ms+1

    where(ssnow%GWtgg .lt. 273.15) 
      css_adj = 3.0
     elsewhere
      css_adj = 1.0
     endwhere
         ssnow%GWgammzz(:) = MAX( ( 1.0 - soil%GWssat(:) ) * soil%css_vec(:,ms)*css_adj(:) * soil%rhosoil_vec(:,ms)   &
                          +  ssnow%GWwb(:) * cswat * C%density_liq ,            &
                           soil%css_vec(:,ms)*css_adj(:) * soil%rhosoil_vec(:,ms) )     &
                          * soil%GWdz(:)

         dtg = dels / ssnow%GWgammzz(:)
         at(:,k) = - dtg * coeff(:,k)
         ct(:,k) = 0.0
         bt(:,k) = 1.0 - at(:,k)


   WHERE( ssnow%isflag == 0 )
      bt(:,1) = bt(:,1) - canopy%dgdtg * dels / ssnow%gammzz(:,1)
      ssnow%tgg(:,1) = ssnow%tgg(:,1) + ( canopy%ga - ssnow%tgg(:,1)           &
                      * REAL( canopy%dgdtg ) ) * dels / REAL( ssnow%gammzz(:,1) )
   END WHERE

   coeff(:,1-3) = 0.0  ! coeff(:,-2)

   ! 3-layer snow points done here
   WHERE( ssnow%isflag /= 0 )

      ssnow%sconds(:,1) = MAX( 0.2, MIN( 2.876e-6 * ssnow%ssdn(:,1)**2         &
                          + 0.074, real(max_sconds,r_2) ) )
      ssnow%sconds(:,2) = MAX(0.2, MIN(2.876e-6 * ssnow%ssdn(:,2)**2 &
                        & + 0.074, real(max_sconds,r_2)) )
      ssnow%sconds(:,3) = MAX(0.2, MIN(2.876e-6 * ssnow%ssdn(:,3)**2 &
                        & + 0.074, real(max_sconds,r_2)) )
      coeff(:,-1) = 2.0 / (ssnow%sdepth(:,1) / ssnow%sconds(:,1) &
                       & + ssnow%sdepth(:,2) / ssnow%sconds(:,2) )
      coeff(:,0) = 2.0 / (ssnow%sdepth(:,2) / ssnow%sconds(:,2) &
                      & + ssnow%sdepth(:,3) / ssnow%sconds(:,3) )
      coeff(:,1) = 2.0 / (ssnow%sdepth(:,3) / ssnow%sconds(:,3) &
                      & + soil%zse_vec(:,1) / ccnsw (:,1) )
   END WHERE

   DO k = 2, ms

      WHERE( ssnow%isflag /= 0 )                                               &
         coeff(:,k) = 2.0 / ( soil%zse_vec(:,k-1) / ccnsw(:,k-1) + soil%zse_vec(:,k) /     &
                      ccnsw(:,k) )

   END DO

   WHERE( ssnow%isflag /= 0 )
      coefa = REAL( coeff (:,-1) )
      coefb = REAL( coeff (:,1) )
   END WHERE

   DO k = 1, 3

      WHERE( ssnow%isflag /= 0 )
         sgamm = ssnow%ssdn(:,k) * cgsnow * ssnow%sdepth(:,k)
         dtg = dels / sgamm
         at(:,k-3) = - dtg * coeff(:,k-3)
         ct(:,k-3) = - dtg * coeff(:,k-2)
         bt(:,k-3) = 1.0 - at(:,k-3) - ct(:,k-3)
      END WHERE

   END DO

   DO k = 1, ms

      WHERE( ssnow%isflag /= 0 )

         ssnow%gammzz(:,k) = MAX( ( 1.0 - soil%ssat_vec(:,k) ) * soil%css_vec(:,k) * soil%rhosoil_vec(:,k)   &
                          + ( ssnow%wbliq(:,k) * cswat * C%density_liq +            &
                          ssnow%wbice(:,k) * csice * C%density_ice ), &
                           soil%css_vec(:,k) * soil%rhosoil_vec(:,k) )     &
                          * soil%zse_vec(:,k)


         dtg = dels / ssnow%gammzz(:,k)
         at(:,k) = - dtg * coeff(:,k)
         ct(:,k) = 0.!- dtg * coeff(:,k + 1) ! c3(ms)=0 & not really used
         bt(:,k) = 1.0 - at(:,k) - ct(:,k)

      END WHERE

   END DO

   WHERE( ssnow%isflag /= 0 )
      sgamm = ssnow%ssdn(:,1) * cgsnow * ssnow%sdepth(:,1)

      bt(:,-2) = bt(:,-2) - canopy%dgdtg * dels / sgamm

      ssnow%tggsn(:,1) = ssnow%tggsn(:,1) + ( canopy%ga - ssnow%tggsn(:,1 )    &
                         * REAL( canopy%dgdtg ) ) * dels / sgamm

      rhs(:,1-3) = ssnow%tggsn(:,1)
   END WHERE


   !     note in the following that tgg and tggsn are processed together
   tmp_mat(:,1:3) = REAL(ssnow%tggsn,r_2)
   tmp_mat(:,4:(ms+3)) = REAL(ssnow%tgg,r_2)
   tmp_mat(:,ms+4) = real(ssnow%GWtgg,r_2)

   CALL trimb( at, bt, ct, tmp_mat, ms + 3 )

   ssnow%tggsn = REAL( tmp_mat(:,1:3) )
   ssnow%tgg   = REAL( tmp_mat(:,4:(ms+3)) )
   ssnow%GWtgg = ssnow%tgg(:,ms)  !real( tmp_mat(:,ms+4) )
   canopy%sghflux = coefa * ( ssnow%tggsn(:,1) - ssnow%tggsn(:,2) )
   canopy%ghflux = coefb * ( ssnow%tgg(:,1) - ssnow%tgg(:,2) ) ! +ve downwards

END SUBROUTINE GWstempv


END MODULE cable_gw_hydro_module
