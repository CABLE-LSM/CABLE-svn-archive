Title: CABLE-MPI.TXT
Author: Maciej Golebiewski
============================================================================


This document describes MPI messages echanged between the master and the
worker ranks in the MPI version of offline CABLE model.


============================================================================
A. OVERVIEW

CABLE-MPI is implemented following the master - worker paradigm. Also, as
the patches and landpoints in CABLE are independent from each other, there
no messages exchanged between the workers (only between the master and the
workers.)

The master rank is:
	1. reading input files
	2. sending the input data to the workers
	3. receiving the results from the workers
	4. writing output files

The worker ranks (there can be 1 or more of workers) are:
	1. receiving input data from the master
	2. computing the landpatches assigned to them
	3. sending the results back to the master


============================================================================
B. MESSAGES EXCHANGED

Each message is made of multiple Fortran arrays (or slices of arrays on
the master). To make the MPI communication more efficient, CABLE-MPI is
using MPI derived datatypes feature to combine all arrays and variables
echanged between the master and each worker so that they can be sent or
received using a single invocation of a send or receive subroutine.

To modify a message (adding or deleting an arrray or changing a type,
size or shape of an array) compatible changes must be done on both the
master and the worker side, in the subroutine that creates the relevant
MPI derived datatypes.


============================================================================
C. TYPES OF MESSAGES

There are different types of messages exchanged between the master and
each worker, each type is defined using its own MPI derived datatype.

On the worker side, each message includes the whole arrays.

On the master side each message includes only the slices of arrays, that
correspond to these points or patches in the decomposed grid that have been
allocated to the worker.

This means that the master needs to create subtypes to accurately describe
slices of multidimensional arrays. For details look below in sections D.2.[bc]

C.1 Messages sent from the master to workers

	C.1.a CABLE parameters (sent once before the main time loop):

		- Master sends param_ts(rank) to worker rank
		- param_ts are created in:
		  cable_mpimaster.F90:master_cable_params

		- Each worker receives param_t
		- param_t is created in:
		  cable_mpiworker.F90:worker_cable_params

	C.1.b CASA parameters (sent once before the main loop but only if
	      icycle > 0):

		- Master sends casap_ts(rank) to worker rank
		- casap_ts are created in:
		  cable_mpimaster.F90:master_casa_params

		- Each worker receives casap_t
		- casap_t is created in:
		  cable_mpiworker.F90:worker_casa_params

	C.1.c CABLE input data (sent once every time step):

		- Master sends inp_ts(rank) to worker rank
		- inp_ts are created in:
		  cable_mpimaster.F90:master_intypes

		- Each worker receives inp_t
		- inp_t is created in:
		  cable_mpiworker.F90:worker_intype

	C.1.d casaCNP spinup parameters (sent once in each spinyear loop
	      but only if doing casaCNP spinup):

		- Master sends spinp_ts(rank) to worker rank
		- spinp_ts are created in:
		  cable_mpimaster.F90:master_spin_params

		- Each worker receives spinp_t
		- spinp_t is created in:
		  cable_mpiworker.F90:worker_spin_params


C.2 Messages sent back from workers to the master

	C.2.a CABLE results (sent once every time step):

		- Each worker sends send_t to the master
		- send_t is created in:
		  cable_mpiworker.F90:worker_outtype

		- Master receives recv_ts(rank) from worker rank
		- recv_ts are created in:
		  cable_mpimaster.F90:master_outtypes

	C.2.b Final CASA results (sent once after the main loop):

		- Each worker sends casa_t to the master
		- casa_t is created in:
		  cable_mpiworker.F90:worker_casa_type

		- Master receives casa_ts(rank) from worker rank
		- casa_ts are created in:
		  cable_mpimaster.F90:master_casa_types

	C.2.c CABLE restart data (sent once after the main loop):

		- Each worker sends restart_t to the master
		- restart_t is created in:
		  cable_mpiworker.F90:worker_restart_type

		- Master receives restart_ts(rank) from worker rank
		- restart_ts are created in:
		  cable_mpimaster.F90:master_restart_types

	C.2.d casaCNP spinup results (called once for each spinup year):

		- Each worker sends spint_t to the master
		- spint_t is created in:
		  cable_mpiworker.F90:worker_spin_totcnp

		- Master receives spint_ts(rank) from worker rank
		- spint_ts are created in:
		  cable_mpimaster.F90:master_spin_totcnp


============================================================================
D. HOW TO MODIFY A MESSAGE

To modify any of the MPI messages exchanged in CABLE-MPI you must make
compatible changes to both master and worker subroutines that create
the message:

Message type	Master types	Master sub in		Worker type	Worker sub in
				cable_mpimaster.F90			cable_mpiworker.F90
-------------------------------------------------------------------------------------------
CABLE params	param_ts	master_cable_params	param_t		worker_cable_params
CABLE input	inp_ts		master_intypes		inp_t		worker_intype
CABLE output	recv_ts		master_outtypes		send_t		worker_outtype
CABLE restart	restart_ts	master_restart_types	restart_t	worker_restart_type

CASA params	casap_ts	master_casa_params	casap_t		worker_casa_param
CASA output	casa_ts		master_casa_types	casa_t		worker_casa_type
CASAspin in	spinp_ts	master_spin_params	spinp_t		worker_spin_params
CASAspin out	spint_ts	master_spin_totcnp	spint_t		worker_spin_totcnp


D.1 HOW TO CHANGE KIND, SIZE OR SHAPE OF AN EXISTING ARRAY

Internally CABLE-MPI treats all variables as a number of contiguous MPI_BYTE vectors. The
length of such a single contiguous vector is determined by the number of land points (or
patches) and the byte-length of each element (e.g. for example REAL(r_1) is 4 bytes long,
so REAL(r_1) :: var(mp) is mp * 4 bytes long; while REAL(r_2) :: var2(mp) is mp * 8 bytes
long).

If the definition of any of the CABLE variables that are send or received by MPI changes,
be it its kind, extent or rank, the subroutines that create the messages that contain such
variable will have to be updated, both on the master and worker sides.


	D.1.a UPDATE KIND:

		- identify all MPI messages that contain the changed variable

		- in the table above look up all master and worker subroutines that create
		  the MPI derived datatypes for the MPI relevant messages

		- in each subroutine identify the lines that refer to the variable
		  in questions

		- update the corresponding block length according to the examples below:

		  * 1D array or vector: a single variable is described by:

			  ! master side:
			  CALL MPI_Get_address (met%tk(off), displs(bidx), ierr)
			  blocks(bidx) = r1len

			to change the block length if KIND changed to r_2:

     			  blocks(bidx) = r2len

                        and similar on the worker side.

		  * 2D Array or matrix:

			  ! master side:
			  CALL MPI_Get_address (met%fsd(off,1), displs(bidx), ierr)
			  CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, &
			  &                             types(bidx), ierr)
			  blocks(bidx) = 1

			update both block length AND stride accordingly (KIND changed to r_2):

			  CALL MPI_Type_create_hvector (swb, r2len, r2stride, MPI_BYTE, &
			  &                             types(bidx), ierr)

			But on the worker side it is similar to vector:

			  ! worker side
			  CALL MPI_Get_address (met%fsd, displs(bidx), ierr)
			  blocks(bidx) = swb * r1len

			Update:

			  blocks(bidx) = swb * r2len

		  * 3D Array or matrix:

			  ! master side
			  CALL MPI_Get_address (rad%qcan(off,1,1), m3daddr(1), ierr)
			  CALL MPI_Type_create_hvector (mf*nrb, r1len, r1stride, MPI_BYTE, &
			  &                        m3d_t(1, rank), ierr)

			update both block length AND stride (e.g. KIND changed to r_2):

			  CALL MPI_Type_create_hvector (mf*nrb, r2len, r2stride, MPI_BYTE, &
			  &                        m3d_t(1, rank), ierr)

			On the worker side similar to matrix or vector:

			  CALL MPI_Get_address (rad%qcan(off,1,1), displs(bidx), ierr)
			  blocks(bidx) = r1len * mf * nrb

			Update:

			  blocks(bidx) = r2len * mf * nrb

		Note: KIND updates on the worker side are easier because the whole array
		is used which means it can be treated as a single contiguous block of
		memory.


	D.1.b UPDATE EXTENT

		When the size of at least one of the dimensions changed.

		- Changed dimension because value of constant parameter changed

		  No changes to MPI code required. Sufficient to rebuild CABLE, including
		  recompiling the MPI modules.

		- Changed dimension because different constant parameter is used

		  * identify all MPI messages that contain the changed variable

		  * in the table above look up all master and worker subroutines that
		    create the MPI derived datatypes for the MPI relevant messages

		  * in each subroutine identify the lines that refer to the variable
		    in questions

		  * update the corresponding block length according to the 2D example below:

		  ! master side
		  CALL MPI_Get_address (casabal%pplantlast(off,1), displs(bidx), ierr)
		  CALL MPI_Type_create_hvector (mplant_old, r2len, r2stride, MPI_BYTE, &
		  &                             types(bidx), ierr)
		  blen(bidx) = 1

		  Update to:

		  CALL MPI_Type_create_hvector (mplant_new, r2len, r2stride, MPI_BYTE, &
		  &                             types(bidx), ierr)

		  Worker side:

		  CALL MPI_Get_address (casabal%pplantlast, displs(bidx), ierr)
		  blen(bidx) = mplant_old * r2len

		  Update to:

		  blen(bidx) = mplant_new * r2len


	D.1.c UPDATE RANK

		When the number of dimensions changed (not very likely, but included for
		the sake of completeness.)


		- Vector to matrix (2D), e.g. REAL(r_1) :: var%array(mp) changed to
		  REAL(r_1) :: var%array(mp,nbands)

		  ! master side
		  CALL MPI_Get_address (var%array(off), displs(bidx), ierr)
		  blen(bidx) = r1len

		  Update to:

		  CALL MPI_Get_address (var%array(off,1), displs(bidx), ierr)
		  CALL MPI_Type_create_hvector (nbands, r1len, r1stride, MPI_BYTE, &
		  &                             types(bidx), ierr)
		  blen(bidx) = 1

		  On the worker side:

		  CALL MPI_Get_address (var%array, displs(bidx), ierr)
		  blen(bidx) = r1len

		  Update to:

		  CALL MPI_Get_address (var%array, displs(bidx), ierr)
		  blen(bidx) = nbands * r1len


		- Matrix (2D) to vector, e.g. REAL(r_1) :: var%array(mp, nbands) changed
		  to REAL(r_1) :: var%array(mp):

		  Basically reverse the vector to matrix update process.


		- 3D array to matrix (2D), e.g. REAL(r_1) :: var%array(mp,na,nb) changed
		  to REAL(r_1) :: var%array(mp,nc)

		  ! master side
		  CALL MPI_Get_address (var%array(off,1,1), displs(bidx), ierr)
		  CALL MPI_Type_create_hvector (na*nb, r1len, r1stride, MPI_BYTE, &
		  &                        types(bidx), ierr)

		  Update to:

		  CALL MPI_Get_address (var%array(off,1), displs(bidx), ierr)
		  CALL MPI_Type_create_hvector (nc, r1len, r1stride, MPI_BYTE, &
		  &                        types(bidx), ierr)

		  On the worker side:

		  CALL MPI_Get_address (var%array, displs(bidx), ierr)
		  blocks(bidx) = r1len * na * nb

		  Update to:

		  blocks(bidx) = r1len * nc


D.2 HOW TO ADD A FIELD/VARIABLE

To add a variable to a message, besides modifying the relevant subroutines on both
the master and worker sides, you will also have to update (increase) the corresponding
constant parameter in cable_mpicommon.F90.

For each type of MPI message exchanged between master and workers there is a constant
parameter that defines the number of variables contained in a message. It is used to
allocate temporary arrays used for creating the MPI derived datatypes and to check
if the number of variables defined in a subroutine is the same as expected.

The constants for each message type are summarised in this table:

Message type	Constant in cable_mpicommon.F90
-----------------------------------------------
CABLE params	nparam
CABLE input	ninput
CABLE output	n3d, nmat, nvec			(to be simplified into nout)
CABLE restart	nrestart

CASA params	ncasaparam
CASA output	ncasa_mat, ncasa_vec		(to be simplified into ncasaout)
CASAspin in	nspinparam
CASAspin out	nspintot


The step by step to add a new variable to an MPI message:

	- identify master and worker subroutines that create the MPI derived
	  datatypes to contain the new variable

	- identify the constant parameter that defines the number of variables
	  in the relevant MPI message and update it (increase)

	- in each subroutine (master and worker) add the new variable in EXACTLY
	  the same position. If the positions in master and workers are different
	  you may experience segmentation faults, but most likely CABLE-MPI will
	  still run but produce incorrect results (and will be very difficult to
	  debug!) To make things easier it is recommended to always append the
	  new variables at the end of existing derived datatypes.

Examples:

	D.2.a Add 1D array or vector to input data sent to workers:

		- New variable is REAL(r_1) :: var%array(mp)

		- Update constant parameter ninput in cable_mpicommon.F90

  		! INTEGER, PARAMETER :: ninput = 15
		! added var%array
  		INTEGER, PARAMETER :: ninput = 16

		- Update master side: datatype is inp_ts, subroutine master_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod(off), displs(bidx), ierr)
		blocks(bidx) = r1len

		! added var%array
		bidx = bidx + 1
		CALL MPI_Get_address (var%array(off), displs(bidx), ierr)
		blocks(bidx) = r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		    WRITE (*,*) 'master: invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Update worker side: datatype is inp_t, subroutine worker_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod, displs(bidx), ierr)
		blocks(bidx) = r1len

		! added var%array
		bidx = bidx + 1
		CALL MPI_Get_address (var%array, displs(bidx), ierr)
		blocks(bidx) = r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		   WRITE (*,*) 'worker: ',rank,': invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Recompile CABLE-MPI


	D.2.b Add 2D array or matrix to input data sent to workers:

		- New variable is REAL(r_1) :: var%array(mp, na)

		- Update constant parameter ninput in cable_mpicommon.F90

  		! INTEGER, PARAMETER :: ninput = 15
		! added var%array
  		INTEGER, PARAMETER :: ninput = 16

		- Update master side: datatype is inp_ts, subroutine master_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod(off), displs(bidx), ierr)
		blocks(bidx) = r1len

		! added var%array
		bidx = bidx + 1
		CALL MPI_Get_address (var%array(off,1), displs(bidx), ierr)
                CALL MPI_Type_create_hvector (na, r1len, r1stride, MPI_BYTE, &
                &                        types(bidx), ierr)
		blocks(bidx) = 1

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		    WRITE (*,*) 'master: invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Update worker side: datatype is inp_t, subroutine worker_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod, displs(bidx), ierr)
		blocks(bidx) = r1len

		! added var%array
		bidx = bidx + 1
		CALL MPI_Get_address (var%array, displs(bidx), ierr)
		blocks(bidx) = na * r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		   WRITE (*,*) 'worker: ',rank,': invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Recompile CABLE-MPI


	D.2.c Add 3D array to input data sent to workers:

		- New variable is REAL(r_1) :: var%array(mp, nb, nc)

		- Update constant parameter ninput in cable_mpicommon.F90

  		! INTEGER, PARAMETER :: ninput = 15
		! added var%array
  		INTEGER, PARAMETER :: ninput = 16

		- Update master side: datatype is inp_ts, subroutine master_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod(off), displs(bidx), ierr)
		blocks(bidx) = r1len

		! added var%array
		bidx = bidx + 1
		CALL MPI_Get_address (var%array(off,1,1), displs(bidx), ierr)
                CALL MPI_Type_create_hvector (nb * nc, r1len, r1stride, MPI_BYTE, &
                &                        types(bidx), ierr)
		blocks(bidx) = 1

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		    WRITE (*,*) 'master: invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Update worker side: datatype is inp_t, subroutine worker_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod, displs(bidx), ierr)
		blocks(bidx) = r1len

		! added var%array
		bidx = bidx + 1
		CALL MPI_Get_address (var%array, displs(bidx), ierr)
		blocks(bidx) = nb * nc * r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		   WRITE (*,*) 'worker: ',rank,': invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Recompile CABLE-MPI


D.3 HOW TO REMOVE A FIELD/VARIABLE

To add a variable to a message, besides modifying the relevant subroutines on both
the master and worker sides, you will also have to update (decrease) the corresponding
constant parameter in cable_mpicommon.F90. For the list of the constants refer to the
table in D.2

The step by step to remove a variable from an MPI message:

	- identify master and worker subroutines that create the MPI derived
	  datatypes to contain the new variable

	- identify the constant parameter that defines the number of variables
	  in the relevant MPI message and update it (decrease)

	- in each subroutine (master and worker) identify the lines that define
	  the variable you want to remove and comment them out (you can remove them
	  later once the new version passed the tests).

Examples:

	D.3.a Remove 1D array or vector from input data sent to workers:

		- Variable to remove is REAL(r_1) :: var%array(mp)

		- Update constant parameter ninput in cable_mpicommon.F90

  		! INTEGER, PARAMETER :: ninput = 16
		! removed var%array
  		INTEGER, PARAMETER :: ninput = 15

		- Update master side: datatype is inp_ts, subroutine master_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod(off), displs(bidx), ierr)
		blocks(bidx) = r1len

		! removed var%array
		!bidx = bidx + 1
		!CALL MPI_Get_address (var%array(off), displs(bidx), ierr)
		!blocks(bidx) = r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		    WRITE (*,*) 'master: invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Update worker side: datatype is inp_t, subroutine worker_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod, displs(bidx), ierr)
		blocks(bidx) = r1len

		! removed var%array
		!bidx = bidx + 1
		!CALL MPI_Get_address (var%array, displs(bidx), ierr)
		!blocks(bidx) = r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		   WRITE (*,*) 'worker: ',rank,': invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Recompile CABLE-MPI


	D.3.b Remove 2D array or matrix from input data sent to workers:

		- Variable to remove is REAL(r_1) :: var%array(mp, na)

		- Update constant parameter ninput in cable_mpicommon.F90

  		! INTEGER, PARAMETER :: ninput = 16
		! removed var%array
  		INTEGER, PARAMETER :: ninput = 15

		- Update master side: datatype is inp_ts, subroutine master_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod(off), displs(bidx), ierr)
		blocks(bidx) = r1len

		! removed var%array
		!bidx = bidx + 1
		!CALL MPI_Get_address (var%array(off,1), displs(bidx), ierr)
                !CALL MPI_Type_create_hvector (na, r1len, r1stride, MPI_BYTE, &
                !&                        types(bidx), ierr)
		!blocks(bidx) = 1

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		    WRITE (*,*) 'master: invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Update worker side: datatype is inp_t, subroutine worker_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod, displs(bidx), ierr)
		blocks(bidx) = r1len

		! removed var%array
		!bidx = bidx + 1
		!CALL MPI_Get_address (var%array, displs(bidx), ierr)
		!blocks(bidx) = na * r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		   WRITE (*,*) 'worker: ',rank,': invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Recompile CABLE-MPI


	D.2.c Remove 3D array from input data sent to workers:

		- Variable to remove is REAL(r_1) :: var%array(mp, nb, nc)

		- Update constant parameter ninput in cable_mpicommon.F90

  		! INTEGER, PARAMETER :: ninput = 16
		! removed var%array
  		INTEGER, PARAMETER :: ninput = 15

		- Update master side: datatype is inp_ts, subroutine master_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod(off), displs(bidx), ierr)
		blocks(bidx) = r1len

		! removed var%array
		!bidx = bidx + 1
		!CALL MPI_Get_address (var%array(off,1,1), displs(bidx), ierr)
                !CALL MPI_Type_create_hvector (nb * nc, r1len, r1stride, MPI_BYTE, &
                !&                        types(bidx), ierr)
		!blocks(bidx) = 1

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		    WRITE (*,*) 'master: invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Update worker side: datatype is inp_t, subroutine worker_intypes

		bidx = bidx + 1
		CALL MPI_Get_address (met%hod, displs(bidx), ierr)
		blocks(bidx) = r1len

		! removed var%array
		!bidx = bidx + 1
		!CALL MPI_Get_address (var%array, displs(bidx), ierr)
		!blocks(bidx) = nb * nc * r1len

		! MPI: sanity check
		IF (bidx /= ntyp) THEN
		   WRITE (*,*) 'worker: ',rank,': invalid intype ninput constant, fix it!'
		   CALL MPI_Abort (comm, 1, ierr)
		END IF

		- Recompile CABLE-MPI

